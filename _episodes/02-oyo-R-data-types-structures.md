---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 02-oyo-R-data-types-structures.md in _episodes_rmd/
title: "R Data Types and Data Structures -- Additional Detail"
classdate: "8/28/2020 -- On Your Own"
teaching: 90
exercises: 30
questions:
- "What are the basic data types in R?"
- "What are factors and how do they differ from other data types?"
- "How is missing data represented in R?"
- "How is infinity represented in R?"
objectives:
- "Understand basic data types in R and how these data types are used in data structures."
- "Understand missing data and other special values (e.g. infinity)."
- "Understand the structure and properties of factors."
- "Be able to explain the difference between ordered and unordered factors."
- "Be aware of some of the problems encountered when using factors."
keypoints:
- "R's basic data types are character, numeric, integer, complex, and logical."
- "R's data structures include the vector, list, matrix, data frame, and factors. Some of these structures require that all members be of the same data type (e.g. vectors, matrices) while others permit multiple data types (e.g. lists, data frames)."
- "Factors are used to represent categorical data."
- "Factors can be *ordered* or *unordered*."
- "Some R functions have special methods for handling factors."
- "The function `dim` gives the dimensions of a data structure."
source: Rmd
---



***
## On Your Own

&nbsp;
### A more in-depth look at Data Types in R

To make the best of the R language, you'll need a strong understanding of the
basic data types and data structures and how to operate on them.

Data structures are very important to understand because these are the objects you 
will manipulate on a day-to-day basis in R. Dealing with object conversions is one
of the most common sources of frustration for beginners.

**Everything** in R is an object.

R has 6 basic data types. In addition to the five listed below, there is also
*raw* which is rarely used and will not be discussed in this course.

* character
* numeric (real or decimal; aka "double")
* integer
* logical
* complex

Elements of these data types may be combined to form data structures, such as
atomic vectors. When we call a vector *atomic*, we mean that the vector only 
holds data of a single data type. Below are examples of atomic character vecotrs,
numeric vectors, integer vectors, etc.

* **character**: `"a"`, `"swc"`
* **numeric**: `2`, `15.5`
* **integer**: `2L` (the `L` tells R to store this as an integer)
* **logical**: `TRUE`, `FALSE`
* **complex**: `1+4i` (complex numbers with real and imaginary parts)

R provides many functions to examine features of vectors and other objects, for
example

* `class()` - what kind of object is it (high-level)?
* `typeof()` - what is the object's data type (low-level)?
* `length()` - how long is it (one-dimensional objects)? 
* `dim()` - what are its dimensions? (two-dimensional objects)?
* `attributes()` - does it have any metadata?

Here are a couple of examples:

~~~
# Example 1 -- a character variable object
x <- "dataset"
typeof(x)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
class(x)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
attributes(x) # simple objects to not have attributes by default
~~~
{: .language-r}



~~~
NULL
~~~
{: .output}



~~~
# Example 2 -- an integer vector object
y <- 1:10
y
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
typeof(y)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}



~~~
length(y)
~~~
{: .language-r}



~~~
[1] 10
~~~
{: .output}



~~~
# Example 3 -- a numeric vector object
z <- as.numeric(y)
z
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
typeof(z)
~~~
{: .language-r}



~~~
[1] "double"
~~~
{: .output}

&nbsp;
#### Examining Vectors

The functions `typeof()`, `length()`, `class()` and `str()` provide useful
information about your vectors and R objects in general.


~~~
typeof(z)
~~~
{: .language-r}



~~~
[1] "double"
~~~
{: .output}



~~~
length(z)
~~~
{: .language-r}



~~~
[1] 10
~~~
{: .output}



~~~
class(z)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}



~~~
str(z) # stands for "structure" of an object
~~~
{: .language-r}



~~~
 num [1:10] 1 2 3 4 5 6 7 8 9 10
~~~
{: .output}

&nbsp;

The first example creates a vector `x` of mode `numeric`. These are the most common kind, and are treated as double precision real numbers. If you wanted to explicitly create integers, you need to add an `L` to each element


~~~
x1 <- c(1L, 2L, 3L)
typeof(x1)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

&nbsp;

You can also *coerce* a vector to the integer type using `as.integer()`.


~~~
x2 <- as.integer(x)
~~~
{: .language-r}



~~~
Warning: NAs introduced by coercion
~~~
{: .error}



~~~
typeof(x2)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}



&nbsp;

R has many __data structures__. These include

* atomic vector
* list
* matrix
* data frame
* factors

***
### Factors

Factors are a special type of data in R, primarily used to represent categorical data. Factors can be ordered or unordered and are an important class for statistical analysis and for plotting.

Factors look (and often behave) like character vectors, but assuming that they are character vectors can lead to unexpected behavior. Factors are actually integers under the hood, and you need to be careful when treating them
like strings. 

Factors have three essential properties:
* A list of integers.
* A set of labels defining the label for the integer.
* An order for the labels.

The integer defines the value of each element in the factor, the label indicates what that value means, and the order defines the relationship between the values.

Once created, factors can only contain a pre-defined set values, known as
*levels*. By default, R sorts *levels* in alphabetical order. For
instance, let's use the `factor()` command to create a factor with 2 levels:



~~~
sex <- factor(c("male", "female", "female", "male"))
sex
~~~
{: .language-r}



~~~
[1] male   female female male  
Levels: female male
~~~
{: .output}

&nbsp;

Now compare this to a similar `character` vector:

~~~
sex.char <- c("male", "female", "female", "male")
sex.char
~~~
{: .language-r}



~~~
[1] "male"   "female" "female" "male"  
~~~
{: .output}

&nbsp;

Note that the elements of `sex.char` have quotation marks, while the object `sex` had a list of levels.

R will assign `1` to the level `"female"` and `2` to the level `"male"` (because
`f` comes before `m`, even though the first element in this vector is
`"male"`). You can check this by using the function `levels()`, and check the
number of levels using `nlevels()`:


~~~
levels(sex)
~~~
{: .language-r}



~~~
[1] "female" "male"  
~~~
{: .output}



~~~
nlevels(sex)
~~~
{: .language-r}



~~~
[1] 2
~~~
{: .output}

&nbsp;

One major functional difference is that the elements of the `character` vector only have the inherent order defined by their values (e.g. alphabetical). Sometimes, the order of the factors does not matter, other times you might want
to specify the order because it is meaningful. For instance, "low", "medium", "high" as elements of a character vector have the implicit alphabetical order:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"high" < "low" < "medium"

while the more meaningful conceptual ordering is:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"low" < "medium" < "high"

Factor levels allow us to specify the conceptual order:

~~~
food <- factor(c("low", "high", "medium", "high", "low", "medium", "high"))
levels(food)
~~~
{: .language-r}



~~~
[1] "high"   "low"    "medium"
~~~
{: .output}



~~~
class(food)
~~~
{: .language-r}



~~~
[1] "factor"
~~~
{: .output}


&nbsp;

Adding the "levels" input to factor defines the level order if it is non-alphabetic


~~~
food <- factor(food, levels = c("low", "medium", "high"))
levels(food)
~~~
{: .language-r}



~~~
[1] "low"    "medium" "high"  
~~~
{: .output}



~~~
class(food)
~~~
{: .language-r}



~~~
[1] "factor"
~~~
{: .output}



~~~
min(food) # note that relative operations do not work; why not?
~~~
{: .language-r}



~~~
Error in Summary.factor(structure(c(1L, 3L, 2L, 3L, 1L, 2L, 3L), .Label = c("low", : 'min' not meaningful for factors
~~~
{: .error}

&nbsp;

If you want R to interpret relative relationships between elements, you have to be explicit that the order of the factors is important.


~~~
food <- factor(food, levels = c("low", "medium", "high"), ordered = TRUE)
levels(food)
~~~
{: .language-r}



~~~
[1] "low"    "medium" "high"  
~~~
{: .output}



~~~
class(food)
~~~
{: .language-r}



~~~
[1] "ordered" "factor" 
~~~
{: .output}



~~~
min(food) # now it works!
~~~
{: .language-r}



~~~
[1] low
Levels: low < medium < high
~~~
{: .output}

&nbsp;

Note that numeric operations still do not work:


~~~
food[1] + food[2]
~~~
{: .language-r}



~~~
Warning in Ops.ordered(food[1], food[2]): '+' is not meaningful for ordered
factors
~~~
{: .error}



~~~
[1] NA
~~~
{: .output}

&nbsp;

In R's memory, these factors are represented by numbers (1, 2, 3). They are
better than using simple integer labels because factors are self describing:
`"low"`, `"medium"`, and `"high"`" is more descriptive than `1`, `2`, `3`. Which
is low?  You wouldn't be able to tell with just integer data. Factors have this
information built in. It is particularly helpful when there are many levels
(like the subjects in our example data set).

What happens if we try to add an element to our factor that is not in the current list of levels?

~~~
length(food)
~~~
{: .language-r}



~~~
[1] 7
~~~
{: .output}



~~~
food[8] <- "frog" # doesn't work! The level "frog" is not defined
~~~
{: .language-r}



~~~
Warning in `[<-.factor`(`*tmp*`, 8, value = "frog"): invalid factor level, NA
generated
~~~
{: .error}



~~~
food[8] <- "low" # note that this works to add an 8th element to `food`
food
~~~
{: .language-r}



~~~
[1] low    high   medium high   low    medium high   low   
Levels: low < medium < high
~~~
{: .output}



~~~
food[10] <- "high" # skipping a spot induces the creation of NAs to fill in data
food
~~~
{: .language-r}



~~~
 [1] low    high   medium high   low    medium high   low    <NA>   high  
Levels: low < medium < high
~~~
{: .output}


> ## Representing Data in R
>
> You have a vector representing levels of exercise undertaken by 5 subjects
>
> **"l", "n", "n", "i", "l"** ; n=none, l=light, i=intense
>
> What is the best way to represent this in R?
>
> 
> ~~~
> exercise <- c("l", "n", "n", "i", "l") # (a)
> exercise <- factor(c("l", "n", "n", "i", "l"), ordered = TRUE) # (b)
> exercise < -factor(c("l", "n", "n", "i", "l"), levels = c("n", "l", "i"), ordered = FALSE) # (c)
> exercise <- factor(c("l", "n", "n", "i", "l"), levels = c("n", "l", "i"), ordered = TRUE) # (d)
> ~~~
> {: .language-r}
>
> > ## Solution
> > Correct solution is **(d)**
> > 
> > ~~~
> > exercise <- factor(c("l", "n", "n", "i", "l"), levels = c("n", "l", "i"), ordered = TRUE)
> > exercise
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] l n n i l
> > Levels: n < l < i
> > ~~~
> > {: .output}
> > &nbsp;
> > 
> > We only expect three categories ("n", "l", "i").
> > We can order these from least intense to most intense, so let's use `ordered`.
> {: .solution}
{: .challenge}

&nbsp;
#### Converting Factors

Converting from a factor to a number can cause problems:


~~~
f <- factor(c(3.4, 1.2, 5))
as.numeric(f)
~~~
{: .language-r}



~~~
[1] 2 1 3
~~~
{: .output}

&nbsp;

This does not behave as expected (and there is no warning). The reason is that the apparent numeric values are actually stored as integers (2, 1, 3) with labels ("3.4", "1.2", "5"). R uses the integer vaue when trying to perform the `as.numeric()` function.

The recommended way is to use the integer vector to index the factor levels:


~~~
levels(f)[f]
~~~
{: .language-r}



~~~
[1] "3.4" "1.2" "5"  
~~~
{: .output}

&nbsp;

The factor really consists of two elements:
* The ordered integer list: `2, 1, 3`
* The "key" indicating which integer corresponds to which level: `1 = 1.2`, `2 = 3.4`, `3 = 5` 

To break this down the `levels(f)[f]`:
1. First we grabe the list of levels using `levels(f)`, which outputs a character vector: "1.2" "3.4" "5".
2. Next we index this list with `[f]`. Because the index requests a numeric representation of the factor `f`, R replaces the `[f]` with `[c(2,1,3)]` (the integer portion of the factor object).
3. R returns the elements of the character list in (1) with the order indicated by the integer list in (2).

To convert that value of `f` to a basic `numeric` type, we still need to assign the values output above using `<-` and the `as.numeric()`:


~~~
f <- levels(f)[f]
f <- as.numeric(f)
f
~~~
{: .language-r}



~~~
[1] 3.4 1.2 5.0
~~~
{: .output}



~~~
class(f)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}

***
### Missing data and special values

R supports both missing data and special values in data structures. 

&nbsp;
#### Missing Data

Missing data is represented as `NA` (Not Available)
and can be used for all the vector types covered in this lesson:


~~~
y1 <- c(0.5, NA, 0.7)
y2 <- c(TRUE, FALSE, NA)
y3 <- c("a", NA, "c", "d", "e")
y4 <- c(1+5i, 2-3i, NA)
~~~
{: .language-r}

&nbsp;

The function `is.na()` indicates the elements of the vectors that represent
missing data, and the function `anyNA()` returns `TRUE` if the vector contains
any missing values:


~~~
x <- c("a", NA, "c", "d", NA)
y <- c("a", "b", "c", "d", "e")
is.na(x)
~~~
{: .language-r}



~~~
[1] FALSE  TRUE FALSE FALSE  TRUE
~~~
{: .output}



~~~
is.na(y)
~~~
{: .language-r}



~~~
[1] FALSE FALSE FALSE FALSE FALSE
~~~
{: .output}



~~~
anyNA(x)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
anyNA(y)
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}

&nbsp;
#### Other Special Values

`Inf` is infinity. You can have either positive or negative infinity.


~~~
1/0
~~~
{: .language-r}



~~~
[1] Inf
~~~
{: .output}



~~~
-1/0
~~~
{: .language-r}



~~~
[1] -Inf
~~~
{: .output}



~~~
10 * Inf
~~~
{: .language-r}



~~~
[1] Inf
~~~
{: .output}



~~~
1/Inf
~~~
{: .language-r}



~~~
[1] 0
~~~
{: .output}

&nbsp;

`NaN` means Not a Number. It's an undefined value. However, it can still be a placeholder in a numeric vector.

~~~
0/0
~~~
{: .language-r}



~~~
[1] NaN
~~~
{: .output}



~~~
2 * NaN
~~~
{: .language-r}



~~~
[1] NaN
~~~
{: .output}



~~~
Inf * NaN
~~~
{: .language-r}



~~~
[1] NaN
~~~
{: .output}



~~~
x = c(1, 2, NaN)
typeof(x)
~~~
{: .language-r}



~~~
[1] "double"
~~~
{: .output}

***

{% include links.md %}
