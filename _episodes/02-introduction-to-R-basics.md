---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 02-introduction-to-R-basics.md in _episodes_rmd/
title: "Introduction to R -- Best Practices, Data Types, and Data Structures"
classdate: "8/29/2019"
teaching: 80
exercises: 25
questions:
- "How should I document my code?"
- "What are the different data types in R?"
- "What are the different data structures in R?"
- "How do I access data within the various data structures?"
- "How do I work with factors?"
- "What is a data frame?"
- "How do I access subsets of a data frame?"
objectives:
- "Employ best practices for documenting code so that others can follow your work."
- "Understand the different data types in R and show how these data types are used in data structures."
- "Create and manipulate vectors of different types."
- "Check the data type of a variable or vector."
- "Understand missing data and other special values."
- "Get familiar with the different data structures (lists, matrices, factors, and data frames)."
- "Know the difference between ordered and unordered factors."
- "Be aware of some of the problems encountered when using factors."
- "Select individual values and subsections from data."
- "Perform operations on a data frame."
- "Understand the three different ways R can address data inside a data frame."
- "Combine different methods for addressing data with the assignment operator to update subsets of data."
keypoints:
- "Use `#` to add comments to programs."
- "Annotate your code!"
- "R's basic data types are character, numeric, integer, complex, and logical."
- "R's basic data structures include the vector, list, matrix, data frame, and factors. Some of these structures require that all members be of the same data type (e.g. vectors, matrices) while others permit multiple data types (e.g. lists, data frames)."
- "Objects may have attributes, such as name, dimension, and class."
- "Factors are used to represent categorical data."
- "Factors can be *ordered* or *unordered*."
- "Some R functions have special methods for handling factors."
- "The function `dim` gives the dimensions of a data frame."
- "Use `object[x, y]` to select a single element from a data frame."
- "Use `from:to` to specify a sequence that includes the indices from `from` to `to`."
- "All the indexing and subsetting that works on data frames also works on vectors."
- "Arguments can be passed by matching based on name, by position, or by omitting them (in which case the default value is used)."
- "Data in data frames can be addressed by index (subsetting), by logical vector, or by name (columns only)."
- "Use the `$` operator to address a column by name."
source: Rmd
---



### Coding Best Practices

What if I handed you this and asked you to explain it:

~~~
newX <- aperm(X, c(s.call, s.ans))
    dim(newX) <- c(prod(d.call), d2)
    ans <- vector("list", d2)
    if (length(d.call) < 2L) {
        if (length(dn.call)) 
            dimnames(newX) <- c(dn.call, list(NULL))
        for (i in 1L:d2) {
            tmp <- forceAndCall(1, FUN, newX[, i], ...)
            if (!is.null(tmp)) 
                ans[[i]] <- tmp
        }
    }
    else for (i in 1L:d2) {
        tmp <- forceAndCall(1, FUN, array(newX[, i], d.call, 
            dn.call), ...)
        if (!is.null(tmp)) 
            ans[[i]] <- tmp
    }
    ans.list <- is.recursive(ans[[1L]])
    l.ans <- length(ans[[1L]])
    ans.names <- names(ans[[1L]])
~~~
{: .language-r}

Got it? Yeah, me neither. For the most part, if you give raw code to someone else, this is what it will look like to them. With time and a lot of messing around, they could probably figure it out, but there is a better way.

Over time, the coding community has developed a set of best practices to follow when writing code to ease the confusion and frustration when someone else tries to read and interpret that code. This isn't just for other people. In a year, that other person trying to interprete you code may be future you.

&nbsp;
Before we start, here is exercise to illustrate the point on even a simple example:

> ## Best coding practices
> 
> Here are what I would consider bad and good practices in coding:
> 
> **Bad:**
> 
> ~~~
> # asign values, then average
> x = 21
> value2 = 26
> bob = (x+value2)/2
> bob
> ~~~
> {: .language-r}
> 
> **Good:**
> 
> ~~~
> # This script will average the body weights of two mice.
> 
> # First enter the body weights of two mice (in grams!)
> bw.mouse1 = 21
> bw.mouse2 = 26
> 
> # Next calculate the average body weight of the two mice
> bw.average = (bw.mouse1 + bw.mouse2) / 2
> 
> # Output the average body weight
> bw.average
> ~~~
> {: .language-r}
>
> What aspects of the "Good" code help you understand the script?
> 
> > ## Solution
> > 
> > Here are some things that I came up with:
> > * Comments are clear and describe the goals of each step of the code.
> > * Header comments summarizes the overall goal of the entire script.
> > * Comments are frequent and explain specific steps.
> > * Variable names are descriptive.
> > * Varaible name formats are consistent.
> > * Steps are visually separated by blank lines to add structure.
> > * Spaces are added to equations to add structure.
> {: .solution}
{: .challenge}


Here are a few habits to develop that will improve your relationship with other coders and your future selves:

&nbsp;
#### Annotation

In the first lesson we introduced the most important best practice: annotate your code thoroughly. Use the `#` to add text to your code that will be ignored by the computer, but helpful to another person trying to figure out just what you did. 

The goal is to allow someone who has never looked at your script before to understand what you are trying to accomplish. Just putting something down is not enough. Make them understand.

&nbsp;
#### Script Header
In addition to adding comments to describe individual actions, adding a detailed header that outlines the purpose and usage of the script is very helpful to frame you analysis. 

&nbsp;
#### Naming Conventions
Historically, R programmers have used a variety of conventions for naming variables. The `.` character in R can be a valid part of a variable name; thus `weight.kg <- 57.5` is a legitimate variable name.

This is often confusing to R newcomers who have programmed in languages where `.` has a more significant meaning. Today, most R programmers:
1. Start variable names with lower case letters
2. Separate words in variable names with underscores
3. Use only lowercase letters, underscores, and numbers in variable names. 

The book *R Packages* includes a [chapter](http://r-pkgs.had.co.nz/style.html) on this and other style considerations.

How closely you follow these standards is up to you. As a good rule of thumb, choose a convention for naming R objects that is descriptive, that you can remember, and that you will stick to using.

***
### Basic Data Types and Data Structures in R

To make the best of the R language, you'll need a strong understanding of the
basic data types and data structures and how to operate on them.

Data structures are very important to understand because these are the objects you 
will manipulate on a day-to-day basis in R. Dealing with object conversions is one
of the most common sources of frustration for beginners.

**Everything** in R is an object.

R has 6 basic data types. In addition to the five listed below, there is also
*raw* which will not be discussed in this course.

* character
* numeric (real or decimal; aka "double")
* integer
* logical
* complex

Elements of these data types may be combined to form data structures, such as
atomic vectors. When we call a vector *atomic*, we mean that the vector only 
holds data of a single data type. Below are examples of atomic character vecotrs,
numeric vectors, integer vectors, etc.

* **character**: `"a"`, `"swc"`
* **numeric**: `2`, `15.5`
* **integer**: `2L` (the `L` tells R to store this as an integer)
* **logical**: `TRUE`, `FALSE`
* **complex**: `1+4i` (complex numbers with real and imaginary parts)

R provides many functions to examine features of vectors and other objects, for
example

* `class()` - what kind of object is it (high-level)?
* `typeof()` - what is the object's data type (low-level)?
* `length()` - how long is it (one-dimensional objects)? 
* `dim()` - what are its dimensions? (two-dimensional objects)?
* `attributes()` - does it have any metadata?

Here are a couple of examples:

~~~
# Example 1 -- a character variable object
x <- "dataset"
typeof(x)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
attributes(x)
~~~
{: .language-r}



~~~
NULL
~~~
{: .output}



~~~
# Example 2 -- an integer vector object
y <- 1:10
y
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
typeof(y)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}



~~~
length(y)
~~~
{: .language-r}



~~~
[1] 10
~~~
{: .output}



~~~
# Example 3 -- a numeric vector object
z <- as.numeric(y)
z
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
typeof(z)
~~~
{: .language-r}



~~~
[1] "double"
~~~
{: .output}

&nbsp;

R has many __data structures__. These include

* atomic vector
* list
* matrix
* data frame
* factors

***
### Vectors

A vector is the most common and basic data structure in R and is pretty much the
workhorse of R. Technically, vectors can be one of two types:

* atomic vectors
* lists

although the term "vector" most commonly refers to the atomic types not to lists.

&nbsp;
#### The Different Vector Modes

A vector is a collection of elements that are most commonly of mode `character`,
`logical`, `integer` or `numeric`.

You can create an empty vector with `vector()`. (By default the mode is
`logical`. You can be more explicit as shown in the examples below.) It is more
common to use direct constructors such as `character()`, `numeric()`, etc.


~~~
vector() # an empty 'logical' (the default) vector
~~~
{: .language-r}



~~~
logical(0)
~~~
{: .output}



~~~
vector("character", length = 5) # a vector of mode 'character' with 5 elements
~~~
{: .language-r}



~~~
[1] "" "" "" "" ""
~~~
{: .output}



~~~
character(5) # the same thing, but using the constructor directly
~~~
{: .language-r}



~~~
[1] "" "" "" "" ""
~~~
{: .output}



~~~
numeric(5)   # a numeric vector with 5 elements
~~~
{: .language-r}



~~~
[1] 0 0 0 0 0
~~~
{: .output}



~~~
logical(5)   # a logical vector with 5 elements
~~~
{: .language-r}



~~~
[1] FALSE FALSE FALSE FALSE FALSE
~~~
{: .output}

&nbsp;

You can also create vectors by directly specifying their content. R will then
guess the appropriate mode of storage for the vector. For instance:


~~~
x <- c(1, 2, 3)
typeof(x)
~~~
{: .language-r}



~~~
[1] "double"
~~~
{: .output}

&nbsp;

This will create a vector `x` of mode `numeric`. These are the most common kind, and
are treated as double precision real numbers. If you wanted to explicitly create
integers, you need to add an `L` to each element


~~~
x1 <- c(1L, 2L, 3L)
typeof(x1)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

&nbsp;

You can also *coerce* a vector to the integer type using `as.integer()`.


~~~
x2 <- as.integer(x)
typeof(x2)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

&nbsp;

Directly specifying `TRUE` and `FALSE` will create a vector of mode `logical`:


~~~
y <- c(TRUE, TRUE, FALSE, FALSE)
typeof(y)
~~~
{: .language-r}



~~~
[1] "logical"
~~~
{: .output}

&nbsp;

While quoted text will create a vector of mode `character`:


~~~
z <- c("Sarah", "Tracy", "Jon")
typeof(z)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}

&nbsp;
#### Examining Vectors

The functions `typeof()`, `length()`, `class()` and `str()` provide useful
information about your vectors and R objects in general.


~~~
typeof(z)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
length(z)
~~~
{: .language-r}



~~~
[1] 3
~~~
{: .output}



~~~
class(z)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
str(z) # stands for "sturcture" of an object
~~~
{: .language-r}



~~~
 chr [1:3] "Sarah" "Tracy" "Jon"
~~~
{: .output}

&nbsp;
#### Adding Elements

The function `c()` (for combine) can also be used to add elements to a vector.


~~~
z <- c(z, "Annette")
z
~~~
{: .language-r}



~~~
[1] "Sarah"   "Tracy"   "Jon"     "Annette"
~~~
{: .output}



~~~
z <- c("Greg", z)
z
~~~
{: .language-r}



~~~
[1] "Greg"    "Sarah"   "Tracy"   "Jon"     "Annette"
~~~
{: .output}

&nbsp;
#### Vectors from a Sequence of Numbers

Use the `seq()` function or the `:` operator to create a vector as a sequence of numbers.


~~~
seq(10)
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
1:10
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
seq(from = 1, to = 10, by = 0.1)
~~~
{: .language-r}



~~~
 [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3
[15]  2.4  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7
[29]  3.8  3.9  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1
[43]  5.2  5.3  5.4  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5
[57]  6.6  6.7  6.8  6.9  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9
[71]  8.0  8.1  8.2  8.3  8.4  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3
[85]  9.4  9.5  9.6  9.7  9.8  9.9 10.0
~~~
{: .output}

&nbsp;
You can assign the sequence directly to a variable:

~~~
series1 = 5:15
series2 = seq(from = 3, to = 8, by = 0.2)
~~~
{: .language-r}

&nbsp;
#### What Happens When You Mix Types Inside a Vector?

R will create a resulting vector with a mode that can most easily accommodate
all the elements it contains. This conversion between modes of storage is called
"coercion". When R converts the mode of storage based on its content, it is
referred to as "implicit coercion". 

> ## Mixing data types in vectors
> 
> What the do you think the following will do (without running them first)?
> 
> 
> ~~~
> z1 <- c(1.7, "a")
> z2 <- c(TRUE, 2)
> z3 <- c("a", TRUE)
> ~~~
> {: .language-r}
> > ## Solution
> > 
> > 
> > ~~~
> > z1 <- c(1.7, "a") 
> > typeof(z1)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "character"
> > ~~~
> > {: .output}
> > `z1` is forced to be a character vector. `"1.7"` can be a character, while `"a"` cannot be a number.
> > 
> > 
> > ~~~
> > z2 <- c(TRUE, 2) 
> > typeof(z2)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "double"
> > ~~~
> > {: .output}
> > `z2` is forced to be a numeric vector. `TRUE` can be interpreted as a number (`TRUE` = `1`, `FALSE` = `0`), while `2` cannot be interpreted as a logical value (or can it?)
> > 
> > 
> > ~~~
> > z3 <- c("a", TRUE)
> > typeof(z3)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "character"
> > ~~~
> > {: .output}
> > `z3` is forced to be a character vector. `"TRUE"` can be a character, while `"a"` cannot be interpreted as a logical value
> > 
> {: .solution}
{: .challenge}

&nbsp;

You can also control how vectors are coerced explicitly using the
`as.[class_name]()` functions:


~~~
as.numeric("1")
~~~
{: .language-r}



~~~
[1] 1
~~~
{: .output}



~~~
as.character(1:2)
~~~
{: .language-r}



~~~
[1] "1" "2"
~~~
{: .output}

&nbsp;

In reality, all numeric and complex values can be interpreted logically:
* 0 = FALSE
* non-0 = TRUE

~~~
as.logical(0)
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}



~~~
as.logical(1)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical(4.2)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical(-5)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical(c(0+0i))
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}



~~~
as.logical(c(1+2i))
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}

&nbsp;

What if we try to force something that cannot be interpreted?


~~~
as.numeric("a")
~~~
{: .language-r}



~~~
Warning: NAs introduced by coercion
~~~
{: .error}



~~~
[1] NA
~~~
{: .output}

> ## Finding Commonalities
>
> What two properties are common to all of the vectors above?
> > ## Solution
> > Properties of vectors:
> > * All vectors are one-dimensional
> > * Each vector element is of the same type.
> {: .solution}
{: .challenge}

&nbsp;
#### Indexing vectors

In R, `[]` are used to index vectors and other objects. For vectors, the number entered in the `[n]` will return the nth element of the vector.


~~~
x = c("a","b","c","d","e","f")
x
~~~
{: .language-r}



~~~
[1] "a" "b" "c" "d" "e" "f"
~~~
{: .output}



~~~
x[5]
~~~
{: .language-r}



~~~
[1] "e"
~~~
{: .output}

&nbsp;

You can also use pre-defined variables or even other vectors to index different parts of the vector:


~~~
n = 6
range = 2:4

x[n] # returns the 6th element, as defined by n = 6
~~~
{: .language-r}



~~~
[1] "f"
~~~
{: .output}



~~~
x[range] # returns the range of values specified by "range", in this case elements 2 to 4.
~~~
{: .language-r}



~~~
[1] "b" "c" "d"
~~~
{: .output}

&nbsp;

We will talk about more advanced indexing later in this lesson.

&nbsp;
#### Vectorized operations

R has a special way of dealing with vectors when dealing with operations. We know what to expect from `1 + 1`, but what happens if you try to add two vectors?

~~~
x = c(1,2,3)
y = c(4,5,6)

z = x + y
z
~~~
{: .language-r}



~~~
[1] 5 7 9
~~~
{: .output}

&nbsp;

R creates a new vector with each element the sum of the elements with the same index from x and y. In essence, R is performing 3 separate "addition" operations and combining the results into a new vector:

~~~
z1 = x[1] + y[1]
z2 = x[2] + y[2]
z3 = x[3] + y[3]

z = c(z1, z2, z3)
z
~~~
{: .language-r}



~~~
[1] 5 7 9
~~~
{: .output}

&nbsp;

This process is called "vectorization". It works for most mathematical operations:

~~~
x-y
~~~
{: .language-r}



~~~
[1] -3 -3 -3
~~~
{: .output}



~~~
x * y
~~~
{: .language-r}



~~~
[1]  4 10 18
~~~
{: .output}



~~~
x/y
~~~
{: .language-r}



~~~
[1] 0.25 0.40 0.50
~~~
{: .output}



~~~
x^y
~~~
{: .language-r}



~~~
[1]   1  32 729
~~~
{: .output}

&nbsp;

Many functions also behave in a vectorized manner. Take the `paste()` function, for example, which combines two or more character variables into a single variable:

~~~
# Here is the output with two strings
paste("I like", "dogs.")
~~~
{: .language-r}



~~~
[1] "I like dogs."
~~~
{: .output}



~~~
# Now let's try pasting two character vectors together:
attitute = c("I like","I dislike","I am indifferent to")
animal = c("dogs.","fish.","cats.")

paste(attitute,animal)
~~~
{: .language-r}



~~~
[1] "I like dogs."              "I dislike fish."          
[3] "I am indifferent to cats."
~~~
{: .output}

&nbsp;

Depending on how they are written and the way their input/output works, some functions may not act on the vector, but on the list of values in the vector. The best way to find out is to give it a try. 

***
### Missing data and special values

R supports both missing data and special values in data structures. 

&nbsp;
#### Missing Data

Missing datais represented as `NA` (Not Available)
and can be used for all the vector types covered in this lesson:


~~~
y1 <- c(0.5, NA, 0.7)
y2 <- c(TRUE, FALSE, NA)
y3 <- c("a", NA, "c", "d", "e")
y4 <- c(1+5i, 2-3i, NA)
~~~
{: .language-r}

&nbsp;

The function `is.na()` indicates the elements of the vectors that represent
missing data, and the function `anyNA()` returns `TRUE` if the vector contains
any missing values:


~~~
x <- c("a", NA, "c", "d", NA)
y <- c("a", "b", "c", "d", "e")
is.na(x)
~~~
{: .language-r}



~~~
[1] FALSE  TRUE FALSE FALSE  TRUE
~~~
{: .output}



~~~
is.na(y)
~~~
{: .language-r}



~~~
[1] FALSE FALSE FALSE FALSE FALSE
~~~
{: .output}



~~~
anyNA(x)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
anyNA(y)
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}

&nbsp;
#### Other Special Values

`Inf` is infinity. You can have either positive or negative infinity.


~~~
1/0
~~~
{: .language-r}



~~~
[1] Inf
~~~
{: .output}



~~~
-1/0
~~~
{: .language-r}



~~~
[1] -Inf
~~~
{: .output}



~~~
10 * Inf
~~~
{: .language-r}



~~~
[1] Inf
~~~
{: .output}



~~~
1/Inf
~~~
{: .language-r}



~~~
[1] 0
~~~
{: .output}

&nbsp;

`NaN` means Not a Number. It's an undefined value. However, it can still be a placeholder in a numeric vector.

~~~
0/0
~~~
{: .language-r}



~~~
[1] NaN
~~~
{: .output}



~~~
2 * NaN
~~~
{: .language-r}



~~~
[1] NaN
~~~
{: .output}



~~~
Inf * NaN
~~~
{: .language-r}



~~~
[1] NaN
~~~
{: .output}



~~~
x = c(1, 2, NaN)
typeof(x)
~~~
{: .language-r}



~~~
[1] "double"
~~~
{: .output}

***
### Objects Attributes

Objects can have __attributes__. Attributes are metadata that are part of the object and describe different aspects of the object. These include:

* names
* dimnames
* dim
* class
* attributes (contain other forms of metadata)

You can also glean other attribute-like information such as length (works on vectors and lists) or number of characters (for character strings).


~~~
length(1:10)
~~~
{: .language-r}



~~~
[1] 10
~~~
{: .output}



~~~
nchar("Software Carpentry")
~~~
{: .language-r}



~~~
[1] 18
~~~
{: .output}

&nbsp;

We will talk more about attributes when we get to more comlex data structures.

***
### Matrices

In R matrices are an extension of the numeric or character vectors. They are not
a separate type of object but simply an atomic vector with dimensions; the
number of rows and columns. As with atomic vectors, the elements of a matrix must
be of the same data type.


~~~
m <- matrix(nrow = 2, ncol = 2)
m
~~~
{: .language-r}



~~~
     [,1] [,2]
[1,]   NA   NA
[2,]   NA   NA
~~~
{: .output}



~~~
dim(m)
~~~
{: .language-r}



~~~
[1] 2 2
~~~
{: .output}

&nbsp;

You can check that matrices are vectors with a class attribute of `matrix` by using
`class()` and `typeof()`.


~~~
m <- matrix(c(1:3))
m
~~~
{: .language-r}



~~~
     [,1]
[1,]    1
[2,]    2
[3,]    3
~~~
{: .output}



~~~
class(m)
~~~
{: .language-r}



~~~
[1] "matrix"
~~~
{: .output}



~~~
typeof(m)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

&nbsp;

While `class()` shows that m is a matrix, `typeof()` shows that fundamentally the
matrix is an integer vector.

Note that one difference between vectors and matrices is that an otherwise identical vector will return the data type of each element when you use `class()`, while the matrix is a new type of object with `class()` "matrix".


~~~
v = 1:3
v
~~~
{: .language-r}



~~~
[1] 1 2 3
~~~
{: .output}



~~~
class(v)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}



~~~
m = as.matrix(v)
m
~~~
{: .language-r}



~~~
     [,1]
[1,]    1
[2,]    2
[3,]    3
~~~
{: .output}



~~~
class(m)
~~~
{: .language-r}



~~~
[1] "matrix"
~~~
{: .output}


> ## Data types of matrix elements
> 
> Consider the following matrix:
> 
> 
> ~~~
> FOURS <- matrix(
>   c(4, 4, 4, 4),
>   nrow = 2,
>   ncol = 2)
> ~~~
> {: .language-r}
>
> Given that `typeof(FOURS[1])` returns `"double"`, what would you expect
> `typeof(FOURS)` to return? How do you know this is the case even without
> running this code?
>
> *Hint* Can matrices be composed of elements of different data types?
>
> > ## Solution
> > We know that `typeof(FOURS)` will also return `"double"` since matrices 
> > are made of elements of the same data type. Note that you could do 
> > something like `as.character(FOURS)` if you needed the elements of `FOURS` 
> > *as characters*.
> {: .solution}
{: .challenge}

&nbsp;

Matrices in R are filled column-wise:


~~~
m1 <- matrix(1:6, nrow = 2, ncol = 3)
m1
~~~
{: .language-r}



~~~
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
~~~
{: .output}

... unless you tell it to fill by row explicitly:


~~~
m2 <- matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)
m2
~~~
{: .language-r}



~~~
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
~~~
{: .output}

&nbsp;

Other ways to construct a matrix


~~~
m      <- 1:10
m # so far m is just a vector!
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
dim(m) <- c(2, 5)
m # defining the dimensions converts m to a matrix
~~~
{: .language-r}



~~~
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10
~~~
{: .output}

&nbsp;

This takes a vector and transforms it into a matrix with 2 rows and 5 columns.

Another way is to bind columns or rows using `rbind()` and `cbind()` ("row bind"
and "column bind", respectively).


~~~
x <- 1:3
y <- 10:12
cbind(x, y)
~~~
{: .language-r}



~~~
     x  y
[1,] 1 10
[2,] 2 11
[3,] 3 12
~~~
{: .output}



~~~
rbind(x, y)
~~~
{: .language-r}



~~~
  [,1] [,2] [,3]
x    1    2    3
y   10   11   12
~~~
{: .output}

&nbsp;
#### Indexing matrices

Like vectors, use `[m,n]` to index the *m*th row and *n*th column of a matrix. The row is always specified before the `,` and the column after.


~~~
m <- matrix(1:10, nrow = 2, ncol = 5)
m
~~~
{: .language-r}



~~~
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10
~~~
{: .output}



~~~
m[2, 3]
~~~
{: .language-r}



~~~
[1] 6
~~~
{: .output}

&nbsp;

What if we ask for an index outside the range of a matrix?


~~~
m[3,15]
~~~
{: .language-r}



~~~
Error in m[3, 15]: subscript out of bounds
~~~
{: .error}

***
### Lists

Lists in R act as containers. Unlike atomic vectors, the contents of a list are
not restricted to a single mode and can encompass any mixture of data
types. Lists are sometimes called "generic vectors"", because the elements of a
list can by of any type of R object, even lists containing further lists. This
property makes them fundamentally different from atomic vectors.

A list is a special type of vector. Each element can be a different type, and is not restricted to a single valuve.

Create lists using `list()` or coerce other objects using `as.list()`. An empty
list of the required length can be created using `vector()`


~~~
x <- list(1, "a", TRUE, 1+4i)
x # A list does not print to the console like a vector. Instead, each element of the list starts on a new line.
~~~
{: .language-r}



~~~
[[1]]
[1] 1

[[2]]
[1] "a"

[[3]]
[1] TRUE

[[4]]
[1] 1+4i
~~~
{: .output}



~~~
x <- vector("list", length = 5) # empty list
length(x)
~~~
{: .language-r}



~~~
[1] 5
~~~
{: .output}



~~~
x 
~~~
{: .language-r}



~~~
[[1]]
NULL

[[2]]
NULL

[[3]]
NULL

[[4]]
NULL

[[5]]
NULL
~~~
{: .output}

&nbsp;

Vectors can be coerced to lists as follows:


~~~
x <- 1:10
x <- as.list(x)
length(x)
~~~
{: .language-r}



~~~
[1] 10
~~~
{: .output}

&nbsp;
#### Indexing lists

Indexing works a bit differently for lists. The content of elements of a list can be retrieved by using double square brackets `[[n]]`, as opposed to the single square brackets `[n]` used for vectors and matrices.


~~~
x[[1]]
~~~
{: .language-r}



~~~
[1] 1
~~~
{: .output}


> ## Examining Lists
>
> 1. What is the class of `x[1]`?
> 2. What is the class of `x[[1]]`?
>
> > ## Solution
> > 1. 
> >     
> >     ~~~
> >     class(x[1])
> >     ~~~
> >     {: .language-r}
> >     
> >     
> >     
> >     ~~~
> >     [1] "list"
> >     ~~~
> >     {: .output}
> > 2. 
> >     
> >     ~~~
> >     class(x[[1]])
> >     ~~~
> >     {: .language-r}
> >     
> >     
> >     
> >     ~~~
> >     [1] "integer"
> >     ~~~
> >     {: .output}
> {: .solution}
{: .challenge}

&nbsp;

Elements of a list can be named (i.e. lists can have the `names` attribute)


~~~
xlist <- list(a = "Karthik Ram", b = 1:10, data = head(iris))
xlist
~~~
{: .language-r}



~~~
$a
[1] "Karthik Ram"

$b
 [1]  1  2  3  4  5  6  7  8  9 10

$data
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa
~~~
{: .output}



~~~
names(xlist)
~~~
{: .language-r}



~~~
[1] "a"    "b"    "data"
~~~
{: .output}



~~~
attributes(xlist)
~~~
{: .language-r}



~~~
$names
[1] "a"    "b"    "data"
~~~
{: .output}

&nbsp;

You can use the `$` operator to directly refer to named list elements by their name:


~~~
xlist[[1]]
~~~
{: .language-r}



~~~
[1] "Karthik Ram"
~~~
{: .output}



~~~
xlist$a
~~~
{: .language-r}



~~~
[1] "Karthik Ram"
~~~
{: .output}

> ## Examining Named Lists
>
> 1. What is the length of the `xlist` object?
> 2. What is its structure?
>
> > ## Solution
> > 1. 
> >     
> >     ~~~
> >     length(xlist)
> >     ~~~
> >     {: .language-r}
> >     
> >     
> >     
> >     ~~~
> >     [1] 3
> >     ~~~
> >     {: .output}
> > 2. 
> >     
> >     ~~~
> >     str(xlist)
> >     ~~~
> >     {: .language-r}
> >     
> >     
> >     
> >     ~~~
> >     List of 3
> >      $ a   : chr "Karthik Ram"
> >      $ b   : int [1:10] 1 2 3 4 5 6 7 8 9 10
> >      $ data:'data.frame':	6 obs. of  5 variables:
> >       ..$ Sepal.Length: num [1:6] 5.1 4.9 4.7 4.6 5 5.4
> >       ..$ Sepal.Width : num [1:6] 3.5 3 3.2 3.1 3.6 3.9
> >       ..$ Petal.Length: num [1:6] 1.4 1.4 1.3 1.5 1.4 1.7
> >       ..$ Petal.Width : num [1:6] 0.2 0.2 0.2 0.2 0.2 0.4
> >       ..$ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1
> >     ~~~
> >     {: .output}
> {: .solution}
{: .challenge} 

&nbsp;
#### Lists of lists!

A list can even have vectors (or other lists!) as one element of a list:


~~~
x <- 1:10
y <- c(T, F, T, T) # "T" can be used in place of "TRUE"; "F" can be used in place of "FALSE"
z <- list(1, "a", TRUE, 1+4i)

my.list <- list(x, y, z)
my.list
~~~
{: .language-r}



~~~
[[1]]
 [1]  1  2  3  4  5  6  7  8  9 10

[[2]]
[1]  TRUE FALSE  TRUE  TRUE

[[3]]
[[3]][[1]]
[1] 1

[[3]][[2]]
[1] "a"

[[3]][[3]]
[1] TRUE

[[3]][[4]]
[1] 1+4i
~~~
{: .output}



~~~
my.list[[1]]
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
class(my.list[[1]])
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}



~~~
class(my.list[[2]])
~~~
{: .language-r}



~~~
[1] "logical"
~~~
{: .output}



~~~
my.list <- list(x = x, y = y, z = x) # use the `=` to name your list eleements
my.list$x
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}

&nbsp;
#### Lists and functions

Lists can be extremely useful inside functions. Because the functions in R are 
able to return only a single object, you can "staple" together lots of different
kinds of results into a single object that a function can return.

Elements are indexed by double brackets. Double brackets return the object inside the indexed list element, while single brackets will just return a(nother) list containing the indicated elements. 


~~~
my.list[1]
~~~
{: .language-r}



~~~
$x
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
my.list[[1]]
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}


&nbsp;

Again, if the elements of a list are named, they can be referenced by
the `$` notation (i.e. `xlist$data`). This can be useful if a function runs a complex analysis. It can export a lot of different types of information as differetn elements in a single list (raw data, processes data, analysis summary, analysis statistics, etc.)

***
### Factors

Factors are a special type of data in R, primarily used to represent categorical data. Factors can be ordered or unordered and are an important class for statistical analysis and for plotting.

Factors look (and often behave) like character vectors, but assuming that they are character vectors can lead to unexpected behavior. Factors are actually actually integers under the hood, and you need to be careful when treating them
like strings. 

Factors have three essential properties:
* A list of integers.
* A set of labels defining the label for the interger.
* An order for the labels.

The integer defines the value of each element in the factor, the label indicates what that value means, and the order defines the relationship between the values.

Once created, factors can only contain a pre-defined set values, known as
*levels*. By default, R sorts *levels* in alphabetical order. For
instance, let's use the `factor()` command to create a factor with 2 levels:



~~~
sex <- factor(c("male", "female", "female", "male"))
sex
~~~
{: .language-r}



~~~
[1] male   female female male  
Levels: female male
~~~
{: .output}

&nbsp;

Now compare this to a similar `character` vector:

~~~
sex.char <- c("male", "female", "female", "male")
sex.char
~~~
{: .language-r}



~~~
[1] "male"   "female" "female" "male"  
~~~
{: .output}

&nbsp;

Note that the elements of `sex.char` have quotation marks, while the object `sex` had a list of levels.

R will assign `1` to the level `"female"` and `2` to the level `"male"` (because
`f` comes before `m`, even though the first element in this vector is
`"male"`). You can check this by using the function `levels()`, and check the
number of levels using `nlevels()`:


~~~
levels(sex)
~~~
{: .language-r}



~~~
[1] "female" "male"  
~~~
{: .output}



~~~
nlevels(sex)
~~~
{: .language-r}



~~~
[1] 2
~~~
{: .output}

&nbsp;

One major functional difference is that the elements of the `character` vector only have the inherent order defined by their vaules (e.g. alphabetical). Sometimes, the order of the factors does not matter, other times you might want
to specify the order because it is meaningful. For instance, "low", "medium", "high" as elements of a character vector have the implicit alphabetical order:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"high" < "low" < "medium"

while the more meaningful conceptual ordering is:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"low" < "medium" < "high"

Factor levels allow us to specify the conceptual order:

~~~
food <- factor(c("low", "high", "medium", "high", "low", "medium", "high"))
levels(food)
~~~
{: .language-r}



~~~
[1] "high"   "low"    "medium"
~~~
{: .output}



~~~
class(food)
~~~
{: .language-r}



~~~
[1] "factor"
~~~
{: .output}


&nbsp;

Adding the "levels" input to factor defines the level order if it is non-alphabetic


~~~
food <- factor(food, levels = c("low", "medium", "high"))
levels(food)
~~~
{: .language-r}



~~~
[1] "low"    "medium" "high"  
~~~
{: .output}



~~~
class(food)
~~~
{: .language-r}



~~~
[1] "factor"
~~~
{: .output}



~~~
min(food) # note that relative operations do not work; why not?
~~~
{: .language-r}



~~~
Error in Summary.factor(structure(c(1L, 3L, 2L, 3L, 1L, 2L, 3L), .Label = c("low", : 'min' not meaningful for factors
~~~
{: .error}

&nbsp;

If you want R to interpret relative relationships between elements, you have to be explicit that the order of the factors is important.


~~~
food <- factor(food, levels = c("low", "medium", "high"), ordered = TRUE)
levels(food)
~~~
{: .language-r}



~~~
[1] "low"    "medium" "high"  
~~~
{: .output}



~~~
class(food)
~~~
{: .language-r}



~~~
[1] "ordered" "factor" 
~~~
{: .output}



~~~
min(food) # now it works!
~~~
{: .language-r}



~~~
[1] low
Levels: low < medium < high
~~~
{: .output}

&nbsp;

Note that numeric operations still do not work:


~~~
food[1] + food[2]
~~~
{: .language-r}



~~~
Warning in Ops.ordered(food[1], food[2]): '+' is not meaningful for ordered
factors
~~~
{: .error}



~~~
[1] NA
~~~
{: .output}

&nbsp;

In R's memory, these factors are represented by numbers (1, 2, 3). They are
better than using simple integer labels because factors are self describing:
`"low"`, `"medium"`, and `"high"`" is more descriptive than `1`, `2`, `3`. Which
is low?  You wouldn't be able to tell with just integer data. Factors have this
information built in. It is particularly helpful when there are many levels
(like the subjects in our example data set).

What happens if we try to add an element to our factor that is not in the current list of levels?

~~~
length(food)
~~~
{: .language-r}



~~~
[1] 7
~~~
{: .output}



~~~
food[8] <- "frog" # doesn't work! The level "frog" is not defined
~~~
{: .language-r}



~~~
Warning in `[<-.factor`(`*tmp*`, 8, value = "frog"): invalid factor level,
NA generated
~~~
{: .error}



~~~
food[8] <- "low" # note that this works to add an 8th element to `food`
food
~~~
{: .language-r}



~~~
[1] low    high   medium high   low    medium high   low   
Levels: low < medium < high
~~~
{: .output}



~~~
food[10] <- "high" # skipping a spot induces the creation of NAs to fill in data
food
~~~
{: .language-r}



~~~
 [1] low    high   medium high   low    medium high   low    <NA>   high  
Levels: low < medium < high
~~~
{: .output}


> ## Representing Data in R
>
> You have a vector representing levels of exercise undertaken by 5 subjects
>
> **"l", "n", "n", "i", "l"** ; n=none, l=light, i=intense
>
> What is the best way to represent this in R?
>
> 
> ~~~
> exercise <- c("l", "n", "n", "i", "l") # (a)
> exercise <- factor(c("l", "n", "n", "i", "l"), ordered = TRUE) # (b)
> exercise < -factor(c("l", "n", "n", "i", "l"), levels = c("n", "l", "i"), ordered = FALSE) # (c)
> exercise <- factor(c("l", "n", "n", "i", "l"), levels = c("n", "l", "i"), ordered = TRUE) # (d)
> ~~~
> {: .language-r}
>
> > ## Solution
> > Correct solution is **(d)**
> > 
> > ~~~
> > exercise <- factor(c("l", "n", "n", "i", "l"), levels = c("n", "l", "i"), ordered = TRUE)
> > exercise
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] l n n i l
> > Levels: n < l < i
> > ~~~
> > {: .output}
> > &nbsp;
> > 
> > We only expect three cathegories ("n", "l", "i").
> > We can order these from least intense to most intense, so let's use `ordered`.
> {: .solution}
{: .challenge}

&nbsp;
#### Converting Factors

Converting from a factor to a number can cause problems:


~~~
f <- factor(c(3.4, 1.2, 5))
as.numeric(f)
~~~
{: .language-r}



~~~
[1] 2 1 3
~~~
{: .output}

&nbsp;

This does not behave as expected (and there is no warning). The reason is that the apparent numeric values are actually stored as intergers (2, 1, 3) with labels ("3.4", "1.2", "5"). R uses the interger vaue when trying to perform the `as.numeric()` function.

The recommended way is to use the integer vector to index the factor levels:


~~~
levels(f)[f]
~~~
{: .language-r}



~~~
[1] "3.4" "1.2" "5"  
~~~
{: .output}

&nbsp;

The factor really consists of two elements:
* The ordered interger list: `2, 1, 3`
* The "key" indicating which interger corresponds to which level: `1 = 1.2`, `2 = 3.4`, `3 = 5` 

To break this down the `levels(f)[f]`:
1. First we grabe the list of levels using `levels(f)`, which outputs a character vector: "1.2" "3.4" "5".
2. Next we index this list with `[f]`. Because the index requests a numeric representation of the factor `f`, R replaces the `[f]` with `[c(2,1,3)]` (the integer portion of the factor object).
3. R returns the elements of the character list in (1) with the order indecated by the integer list in (2).

To convert that value of `f` to a basic `numeric` type, we still need to assign the values output above using `<-` and the `as.numeric()`:


~~~
f <- levels(f)[f]
f <- as.numeric(f)
f
~~~
{: .language-r}



~~~
[1] 3.4 1.2 5.0
~~~
{: .output}



~~~
class(f)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}

***
### Data Frames

The data frame is the most important data type in R. It is the *de facto*
data structure for most tabular data and what we use for statistics. At its heart, the data frame is a *special type of list* where every element of the list has same length (i.e. data frame is a "rectangular" list).

Data frames can have additional attributes such as `rownames()`, which can be
useful for annotating data, like `subject_id` or `sample_id`. But most of the
time they are not used.

Data frame characteristics:
* Each column must contain a single data type
* Different columns can have different data types
* All columns must have the same number of elements
* Like lists, column names can be directly called using the `$` operator
* Like matrices, data frames can be indexed using the `df[row,column]` notation.

Some additional information on data frames:

* Created by the `read.csv()` and `read.table()` when importing the data into R.
* Assuming all columns in a data frame are of same type, data frame can be converted to a matrix with data.matrix() (preferred) or as.matrix(). Otherwise type coercion will be enforced and the results may not always be what you expect.
* Can be created *de novo* with the `data.frame()` or `as.data.frame()` functions.
* Like matrices, the number of rows and columns can be queried with `nrow(dat)` and `ncol(dat)`, respectively.
* Rownames are often automatically generated and look like 1, 2, ..., n. Consistency in numbering of rownames may not be honored when rows are reshuffled or subset.
* A common way to use data frames is with columns as "variables" (e.g. body weight, blood pressure) and rows as "patients" or "observations" (e.g. "subject 1", "subject 2", ...).

The following table summarizes the one-dimensional and two-dimensional data structures in 
R in relation to diversity of data types they can contain.

| Dimensions | Homogenous | Heterogeneous |
| ------- | ---- | ---- |
| 1-D | atomic vector | list |
| 2-D | matrix | data frame |

&nbsp;
#### Creating Data Frames by Hand

To create data frames by hand:


~~~
dat <- data.frame(id = letters[1:10], x = 1:10, y = 11:20)
dat
~~~
{: .language-r}



~~~
   id  x  y
1   a  1 11
2   b  2 12
3   c  3 13
4   d  4 14
5   e  5 15
6   f  6 16
7   g  7 17
8   h  8 18
9   i  9 19
10  j 10 20
~~~
{: .output}

&nbsp;

See that it is actually a special list:


~~~
is.list(dat)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
is.data.frame(dat) # "data.frame" is a sub-class of "list"
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
class(dat)
~~~
{: .language-r}



~~~
[1] "data.frame"
~~~
{: .output}

&nbsp;
#### Sample data in R

R includes a default dataset that can be used for examples caused `iris`. The `iris` data frame is already defined and loaded in memory. We will use this data frame to learn how to interact with data frames. 

Let's get some information on the `iris` data set:

~~~
?iris
~~~
{: .language-r}

&nbsp;
#### Useful function for examining and extracting information from data frames

There are many ways to interact with data frames and get information about their contents.

> ## Useful Data Frame Functions
>
> * `head()` - shows first 6 rows
> * `tail()` - shows last 6 rows
> * `dim()` - returns the dimensions of data frame (i.e. number of rows and number of columns)
> * `nrow()` - number of rows
> * `ncol()` - number of columns
> * `str()` - structure of data frame - name, type and preview of data in each column
> * `names()` or `colnames()` - both show the `names` attribute for a data frame
> * `sapply(dataframe, class)` - shows the class of each column in the data frame
{: .callout}

&nbsp;

I find `head()`, which displays the first 6 rows and all columns of the data frame, particularly useful to get a feel for the contents and organization of a new data frame. Let's take a quick look at `iris` with `head()` and `dim()`:


~~~
head(iris)
~~~
{: .language-r}



~~~
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa
~~~
{: .output}



~~~
head(iris, 2) # you can look at more or fewer rows if 6 is not what you want
~~~
{: .language-r}



~~~
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
~~~
{: .output}



~~~
dim(iris)
~~~
{: .language-r}



~~~
[1] 150   5
~~~
{: .output}

> ## Column Types in Data Frames
>
> Knowing that data frames are lists, can columns be of different type?
>
> What type of structure do you expect to see when you explore the structure of the `iris` data 
> frame? Hint: Use `str()`.
>
> > ## Solution
> > The Sepal.Length, Sepal.Width, Petal.Length and Petal.Width columns are all
> > numeric types, while Species is a Factor.
> > Lists can have elements of different types.
> > Since a Data Frame is just a special type of list, it can have columns of
> > differing type (although, remember that type must be consistent within each column!).
> > 
> > ~~~
> > str(iris)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > 'data.frame':	150 obs. of  5 variables:
> >  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
> >  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
> >  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
> >  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
> >  $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

&nbsp;
#### Indexing data frames

R is a powerful language for data manipulation. There are three main ways for addressing data inside R objects.

* By index (subsetting)
* By name (columns only)
* By logical vector

&nbsp;

**By index**

Because data frames are rectangular, elements of data frame can be referenced by specifying 
the row and the column index in single square brackets (similar to matrix).


~~~
iris[1, 3]
~~~
{: .language-r}



~~~
[1] 1.4
~~~
{: .output}

&nbsp;

Like matrices, we can also ask for multiple collumns and rows using the `:` operator:

~~~
iris[1:20, 2:3]
~~~
{: .language-r}



~~~
   Sepal.Width Petal.Length
1          3.5          1.4
2          3.0          1.4
3          3.2          1.3
4          3.1          1.5
5          3.6          1.4
6          3.9          1.7
7          3.4          1.4
8          3.4          1.5
9          2.9          1.4
10         3.1          1.5
11         3.7          1.5
12         3.4          1.6
13         3.0          1.4
14         3.0          1.1
15         4.0          1.2
16         4.4          1.5
17         3.9          1.3
18         3.5          1.4
19         3.8          1.7
20         3.8          1.5
~~~
{: .output}

&nbsp;

Or for non-contiguous subsets using lists of indices:

~~~
iris[c(1:10,20:25), c(1,3)] # note the use of sequences within the `c()` list
~~~
{: .language-r}



~~~
   Sepal.Length Petal.Length
1           5.1          1.4
2           4.9          1.4
3           4.7          1.3
4           4.6          1.5
5           5.0          1.4
6           5.4          1.7
7           4.6          1.4
8           5.0          1.5
9           4.4          1.4
10          4.9          1.5
20          5.1          1.5
21          5.4          1.7
22          5.1          1.5
23          4.6          1.0
24          5.1          1.7
25          4.8          1.9
~~~
{: .output}

&nbsp;

What if we only ask for one dimension in data frame?

> ## Asking for a single index from a data frame
> 
> What do you expect if we query `iris` with just one index?
> 
> 
> ~~~
> iris[3]
> ~~~
> {: .language-r}
> > ## Solution
> > 
> > ~~~
> > iris[3]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >     Petal.Length
> > 1            1.4
> > 2            1.4
> > 3            1.3
> > 4            1.5
> > 5            1.4
> > 6            1.7
> > 7            1.4
> > 8            1.5
> > 9            1.4
> > 10           1.5
> > 11           1.5
> > 12           1.6
> > 13           1.4
> > 14           1.1
> > 15           1.2
> > 16           1.5
> > 17           1.3
> > 18           1.4
> > 19           1.7
> > 20           1.5
> > 21           1.7
> > 22           1.5
> > 23           1.0
> > 24           1.7
> > 25           1.9
> > 26           1.6
> > 27           1.6
> > 28           1.5
> > 29           1.4
> > 30           1.6
> > 31           1.6
> > 32           1.5
> > 33           1.5
> > 34           1.4
> > 35           1.5
> > 36           1.2
> > 37           1.3
> > 38           1.4
> > 39           1.3
> > 40           1.5
> > 41           1.3
> > 42           1.3
> > 43           1.3
> > 44           1.6
> > 45           1.9
> > 46           1.4
> > 47           1.6
> > 48           1.4
> > 49           1.5
> > 50           1.4
> > 51           4.7
> > 52           4.5
> > 53           4.9
> > 54           4.0
> > 55           4.6
> > 56           4.5
> > 57           4.7
> > 58           3.3
> > 59           4.6
> > 60           3.9
> > 61           3.5
> > 62           4.2
> > 63           4.0
> > 64           4.7
> > 65           3.6
> > 66           4.4
> > 67           4.5
> > 68           4.1
> > 69           4.5
> > 70           3.9
> > 71           4.8
> > 72           4.0
> > 73           4.9
> > 74           4.7
> > 75           4.3
> > 76           4.4
> > 77           4.8
> > 78           5.0
> > 79           4.5
> > 80           3.5
> > 81           3.8
> > 82           3.7
> > 83           3.9
> > 84           5.1
> > 85           4.5
> > 86           4.5
> > 87           4.7
> > 88           4.4
> > 89           4.1
> > 90           4.0
> > 91           4.4
> > 92           4.6
> > 93           4.0
> > 94           3.3
> > 95           4.2
> > 96           4.2
> > 97           4.2
> > 98           4.3
> > 99           3.0
> > 100          4.1
> > 101          6.0
> > 102          5.1
> > 103          5.9
> > 104          5.6
> > 105          5.8
> > 106          6.6
> > 107          4.5
> > 108          6.3
> > 109          5.8
> > 110          6.1
> > 111          5.1
> > 112          5.3
> > 113          5.5
> > 114          5.0
> > 115          5.1
> > 116          5.3
> > 117          5.5
> > 118          6.7
> > 119          6.9
> > 120          5.0
> > 121          5.7
> > 122          4.9
> > 123          6.7
> > 124          4.9
> > 125          5.7
> > 126          6.0
> > 127          4.8
> > 128          4.9
> > 129          5.6
> > 130          5.8
> > 131          6.1
> > 132          6.4
> > 133          5.6
> > 134          5.1
> > 135          5.6
> > 136          6.1
> > 137          5.6
> > 138          5.5
> > 139          4.8
> > 140          5.4
> > 141          5.6
> > 142          5.1
> > 143          5.1
> > 144          5.9
> > 145          5.7
> > 146          5.2
> > 147          5.0
> > 148          5.2
> > 149          5.4
> > 150          5.1
> > ~~~
> > {: .output}
> > Because the data frame is a list at heart, just asking for a single index returns 
> > the indicated column.
> >
> {: .solution}
{: .challenge}

&nbsp;

What if we include the `,`, but don't give an actual index?

> ## Selecting More Values
>
> What will be returned by `dat[, 2]`?
>
> > ## Solution
> > 
> > ~~~
> > dat[, 2]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >  [1]  1  2  3  4  5  6  7  8  9 10
> > ~~~
> > {: .output}
> >
> > If we leave out a dimension R will interpret this as a request for all values in 
> > that dimension.
> {: .solution}
{: .challenge}

&nbsp;

**By name (columns only)**

As data frames are also lists, it is possible to refer to columns (which are elements of
such list) using the list notation, i.e. either double square brackets or a `$`.


~~~
# These all return the same vector:
iris[[1]]
~~~
{: .language-r}



~~~
  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4
 [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5
 [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0
 [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8
 [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4
 [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8
[103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7
[120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7
[137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9
~~~
{: .output}



~~~
iris[["Sepal.Length"]]
~~~
{: .language-r}



~~~
  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4
 [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5
 [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0
 [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8
 [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4
 [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8
[103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7
[120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7
[137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9
~~~
{: .output}



~~~
iris$Sepal.Length
~~~
{: .language-r}



~~~
  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4
 [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5
 [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0
 [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8
 [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4
 [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8
[103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7
[120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7
[137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9
~~~
{: .output}

&nbsp;

We can ask for a set of columns using `c()`:


~~~
iris[1:10, c("Sepal.Length","Petal.Length")]
~~~
{: .language-r}



~~~
   Sepal.Length Petal.Length
1           5.1          1.4
2           4.9          1.4
3           4.7          1.3
4           4.6          1.5
5           5.0          1.4
6           5.4          1.7
7           4.6          1.4
8           5.0          1.5
9           4.4          1.4
10          4.9          1.5
~~~
{: .output}

&nbsp;

Named vectors can also be used in vectorized mathematical operations:


~~~
iris$Sepal.Length + iris$Petal.Length
~~~
{: .language-r}



~~~
  [1]  6.5  6.3  6.0  6.1  6.4  7.1  6.0  6.5  5.8  6.4  6.9  6.4  6.2  5.4
 [15]  7.0  7.2  6.7  6.5  7.4  6.6  7.1  6.6  5.6  6.8  6.7  6.6  6.6  6.7
 [29]  6.6  6.3  6.4  6.9  6.7  6.9  6.4  6.2  6.8  6.3  5.7  6.6  6.3  5.8
 [43]  5.7  6.6  7.0  6.2  6.7  6.0  6.8  6.4 11.7 10.9 11.8  9.5 11.1 10.2
 [57] 11.0  8.2 11.2  9.1  8.5 10.1 10.0 10.8  9.2 11.1 10.1  9.9 10.7  9.5
 [71] 10.7 10.1 11.2 10.8 10.7 11.0 11.6 11.7 10.5  9.2  9.3  9.2  9.7 11.1
 [85]  9.9 10.5 11.4 10.7  9.7  9.5  9.9 10.7  9.8  8.3  9.8  9.9  9.9 10.5
 [99]  8.1  9.8 12.3 10.9 13.0 11.9 12.3 14.2  9.4 13.6 12.5 13.3 11.6 11.7
[113] 12.3 10.7 10.9 11.7 12.0 14.4 14.6 11.0 12.6 10.5 14.4 11.2 12.4 13.2
[127] 11.0 11.0 12.0 13.0 13.5 14.3 12.0 11.4 11.7 13.8 11.9 11.9 10.8 12.3
[141] 12.3 12.0 10.9 12.7 12.4 11.9 11.3 11.7 11.6 11.0
~~~
{: .output}

> ## Default Names
>
> If column names are not specified, `V1, V2, ..., Vn` are automatically used as the defaults. For example, if we convert a matrix to a data frame:
> 
> 
> ~~~
> m = matrix(1:10, nrow = 2)
> m.data = as.data.frame(m)
> m.data
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
>   V1 V2 V3 V4 V5
> 1  1  3  5  7  9
> 2  2  4  6  8 10
> ~~~
> {: .output}
{: .callout}

&nbsp;

**By logical vector**

Recall that a logical vector contains only the special values `TRUE` and `FALSE`.


~~~
c(TRUE, TRUE, FALSE, FALSE, TRUE)
~~~
{: .language-r}



~~~
[1]  TRUE  TRUE FALSE FALSE  TRUE
~~~
{: .output}

&nbsp;

Logical vectors can be created using `relational operators`:
* `<` = less than
* `>` = greater than
* `<=` = less than or equal to
* `>=` = greater than or equal to
* `==` = exactly equal to
* `!=` = not equal to
* `%in%` = is present in (to as if the value on the left is present in the vector/matrix on the right)

A few single variable examples:

~~~
1 == 1
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
1 == 2
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}



~~~
1 != 1
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}



~~~
4 > 7
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}



~~~
18 %in% 1:10
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}



~~~
18 %in% 15:25
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}

&nbsp;

We can use these operators to query entire vectors and generate logical vectors:


~~~
# creating logical vectors from numeric data
x <- c(1, 2, 3, 11, 12, 13)
x < 10
~~~
{: .language-r}



~~~
[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE
~~~
{: .output}



~~~
x %in% 1:10
~~~
{: .language-r}



~~~
[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE
~~~
{: .output}

&nbsp;

We can use logical vectors to select data from a data frame.


~~~
index <- iris$Species == 'setosa'
index
~~~
{: .language-r}



~~~
  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [12]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [23]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [34]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [45]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
 [56] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [67] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [78] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [89] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[100] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[111] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[122] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[144] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
~~~
{: .output}



~~~
iris[index,]
~~~
{: .language-r}



~~~
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1           5.1         3.5          1.4         0.2  setosa
2           4.9         3.0          1.4         0.2  setosa
3           4.7         3.2          1.3         0.2  setosa
4           4.6         3.1          1.5         0.2  setosa
5           5.0         3.6          1.4         0.2  setosa
6           5.4         3.9          1.7         0.4  setosa
7           4.6         3.4          1.4         0.3  setosa
8           5.0         3.4          1.5         0.2  setosa
9           4.4         2.9          1.4         0.2  setosa
10          4.9         3.1          1.5         0.1  setosa
11          5.4         3.7          1.5         0.2  setosa
12          4.8         3.4          1.6         0.2  setosa
13          4.8         3.0          1.4         0.1  setosa
14          4.3         3.0          1.1         0.1  setosa
15          5.8         4.0          1.2         0.2  setosa
16          5.7         4.4          1.5         0.4  setosa
17          5.4         3.9          1.3         0.4  setosa
18          5.1         3.5          1.4         0.3  setosa
19          5.7         3.8          1.7         0.3  setosa
20          5.1         3.8          1.5         0.3  setosa
21          5.4         3.4          1.7         0.2  setosa
22          5.1         3.7          1.5         0.4  setosa
23          4.6         3.6          1.0         0.2  setosa
24          5.1         3.3          1.7         0.5  setosa
25          4.8         3.4          1.9         0.2  setosa
26          5.0         3.0          1.6         0.2  setosa
27          5.0         3.4          1.6         0.4  setosa
28          5.2         3.5          1.5         0.2  setosa
29          5.2         3.4          1.4         0.2  setosa
30          4.7         3.2          1.6         0.2  setosa
31          4.8         3.1          1.6         0.2  setosa
32          5.4         3.4          1.5         0.4  setosa
33          5.2         4.1          1.5         0.1  setosa
34          5.5         4.2          1.4         0.2  setosa
35          4.9         3.1          1.5         0.2  setosa
36          5.0         3.2          1.2         0.2  setosa
37          5.5         3.5          1.3         0.2  setosa
38          4.9         3.6          1.4         0.1  setosa
39          4.4         3.0          1.3         0.2  setosa
40          5.1         3.4          1.5         0.2  setosa
41          5.0         3.5          1.3         0.3  setosa
42          4.5         2.3          1.3         0.3  setosa
43          4.4         3.2          1.3         0.2  setosa
44          5.0         3.5          1.6         0.6  setosa
45          5.1         3.8          1.9         0.4  setosa
46          4.8         3.0          1.4         0.3  setosa
47          5.1         3.8          1.6         0.2  setosa
48          4.6         3.2          1.4         0.2  setosa
49          5.3         3.7          1.5         0.2  setosa
50          5.0         3.3          1.4         0.2  setosa
~~~
{: .output}

&nbsp;

Often this operation is written as one line of code:


~~~
iris[iris$Species == 'setosa', ]
~~~
{: .language-r}



~~~
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1           5.1         3.5          1.4         0.2  setosa
2           4.9         3.0          1.4         0.2  setosa
3           4.7         3.2          1.3         0.2  setosa
4           4.6         3.1          1.5         0.2  setosa
5           5.0         3.6          1.4         0.2  setosa
6           5.4         3.9          1.7         0.4  setosa
7           4.6         3.4          1.4         0.3  setosa
8           5.0         3.4          1.5         0.2  setosa
9           4.4         2.9          1.4         0.2  setosa
10          4.9         3.1          1.5         0.1  setosa
11          5.4         3.7          1.5         0.2  setosa
12          4.8         3.4          1.6         0.2  setosa
13          4.8         3.0          1.4         0.1  setosa
14          4.3         3.0          1.1         0.1  setosa
15          5.8         4.0          1.2         0.2  setosa
16          5.7         4.4          1.5         0.4  setosa
17          5.4         3.9          1.3         0.4  setosa
18          5.1         3.5          1.4         0.3  setosa
19          5.7         3.8          1.7         0.3  setosa
20          5.1         3.8          1.5         0.3  setosa
21          5.4         3.4          1.7         0.2  setosa
22          5.1         3.7          1.5         0.4  setosa
23          4.6         3.6          1.0         0.2  setosa
24          5.1         3.3          1.7         0.5  setosa
25          4.8         3.4          1.9         0.2  setosa
26          5.0         3.0          1.6         0.2  setosa
27          5.0         3.4          1.6         0.4  setosa
28          5.2         3.5          1.5         0.2  setosa
29          5.2         3.4          1.4         0.2  setosa
30          4.7         3.2          1.6         0.2  setosa
31          4.8         3.1          1.6         0.2  setosa
32          5.4         3.4          1.5         0.4  setosa
33          5.2         4.1          1.5         0.1  setosa
34          5.5         4.2          1.4         0.2  setosa
35          4.9         3.1          1.5         0.2  setosa
36          5.0         3.2          1.2         0.2  setosa
37          5.5         3.5          1.3         0.2  setosa
38          4.9         3.6          1.4         0.1  setosa
39          4.4         3.0          1.3         0.2  setosa
40          5.1         3.4          1.5         0.2  setosa
41          5.0         3.5          1.3         0.3  setosa
42          4.5         2.3          1.3         0.3  setosa
43          4.4         3.2          1.3         0.2  setosa
44          5.0         3.5          1.6         0.6  setosa
45          5.1         3.8          1.9         0.4  setosa
46          4.8         3.0          1.4         0.3  setosa
47          5.1         3.8          1.6         0.2  setosa
48          4.6         3.2          1.4         0.2  setosa
49          5.3         3.7          1.5         0.2  setosa
50          5.0         3.3          1.4         0.2  setosa
~~~
{: .output}

> ## Using logical indices
>
> Create a new data frame that is the subset of `iris` with sepal length greater than or
> equal to 5.0.
> 
> > ## Solution
> > 
> > ~~~
> > iris.new = iris[iris$Sepal.Length > 5,]
> > ~~~
> > {: .language-r}
> {: .solution}
{: .challenge}

&nbsp;

In addition to the numeric comparisons, there are a set of operators that compare logical variables and output a new logical variable:
* `!` = NOT (changes `TRUE` to `FALSE` and vise versa)
* `&` = element-wise AND (both are true; outputs vector for vector input comparing elements)
* `&&` = logical AND (both are true; only considers first index of a vector)
* `|` = element-wise OR (one or both are true; outputs vector for vector input comparing elements)
* `&&` = logical OR (both are true; only considers first index of a vector)


~~~
truth = c(TRUE, FALSE, TRUE, TRUE)
lie = !truth
truth
~~~
{: .language-r}



~~~
[1]  TRUE FALSE  TRUE  TRUE
~~~
{: .output}



~~~
lie
~~~
{: .language-r}



~~~
[1] FALSE  TRUE FALSE FALSE
~~~
{: .output}



~~~
T & T
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
T & F
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}



~~~
T | F
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
F | F
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}

***
### Exercises

> ## Using logical indices
>
> Create a new data frame that is the subset of `iris` with sepal length greater than or > equal to 5.0 for the setosa species.
> 
> > ## Solution
> > 
> > ~~~
> > iris.new = iris[iris$Sepal.Length > 5 & iris$Species == "setosa",]
> > ~~~
> > {: .language-r}
> {: .solution}
{: .challenge}

> ## Subsetting using a vector or name
>
> Use the colon operator to index the first five observations of just the sepal  
> length and species from `iris`
>
> > ## Solution
> > Two options:
> > 
> > ~~~
> > iris[1:5, c(1,5)]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >   Sepal.Length Species
> > 1          5.1  setosa
> > 2          4.9  setosa
> > 3          4.7  setosa
> > 4          4.6  setosa
> > 5          5.0  setosa
> > ~~~
> > {: .output}
> > 
> > 
> > 
> > ~~~
> > iris[1:5,c("Sepal.Length","Species")]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >   Sepal.Length Species
> > 1          5.1  setosa
> > 2          4.9  setosa
> > 3          4.7  setosa
> > 4          4.6  setosa
> > 5          5.0  setosa
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Subsetting with Sequences
>
> Use the colon operator to index just the data on sepal size from `iris`
>
> > ## Solution
> > 
> > ~~~
> > iris[, 1:2]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >     Sepal.Length Sepal.Width
> > 1            5.1         3.5
> > 2            4.9         3.0
> > 3            4.7         3.2
> > 4            4.6         3.1
> > 5            5.0         3.6
> > 6            5.4         3.9
> > 7            4.6         3.4
> > 8            5.0         3.4
> > 9            4.4         2.9
> > 10           4.9         3.1
> > 11           5.4         3.7
> > 12           4.8         3.4
> > 13           4.8         3.0
> > 14           4.3         3.0
> > 15           5.8         4.0
> > 16           5.7         4.4
> > 17           5.4         3.9
> > 18           5.1         3.5
> > 19           5.7         3.8
> > 20           5.1         3.8
> > 21           5.4         3.4
> > 22           5.1         3.7
> > 23           4.6         3.6
> > 24           5.1         3.3
> > 25           4.8         3.4
> > 26           5.0         3.0
> > 27           5.0         3.4
> > 28           5.2         3.5
> > 29           5.2         3.4
> > 30           4.7         3.2
> > 31           4.8         3.1
> > 32           5.4         3.4
> > 33           5.2         4.1
> > 34           5.5         4.2
> > 35           4.9         3.1
> > 36           5.0         3.2
> > 37           5.5         3.5
> > 38           4.9         3.6
> > 39           4.4         3.0
> > 40           5.1         3.4
> > 41           5.0         3.5
> > 42           4.5         2.3
> > 43           4.4         3.2
> > 44           5.0         3.5
> > 45           5.1         3.8
> > 46           4.8         3.0
> > 47           5.1         3.8
> > 48           4.6         3.2
> > 49           5.3         3.7
> > 50           5.0         3.3
> > 51           7.0         3.2
> > 52           6.4         3.2
> > 53           6.9         3.1
> > 54           5.5         2.3
> > 55           6.5         2.8
> > 56           5.7         2.8
> > 57           6.3         3.3
> > 58           4.9         2.4
> > 59           6.6         2.9
> > 60           5.2         2.7
> > 61           5.0         2.0
> > 62           5.9         3.0
> > 63           6.0         2.2
> > 64           6.1         2.9
> > 65           5.6         2.9
> > 66           6.7         3.1
> > 67           5.6         3.0
> > 68           5.8         2.7
> > 69           6.2         2.2
> > 70           5.6         2.5
> > 71           5.9         3.2
> > 72           6.1         2.8
> > 73           6.3         2.5
> > 74           6.1         2.8
> > 75           6.4         2.9
> > 76           6.6         3.0
> > 77           6.8         2.8
> > 78           6.7         3.0
> > 79           6.0         2.9
> > 80           5.7         2.6
> > 81           5.5         2.4
> > 82           5.5         2.4
> > 83           5.8         2.7
> > 84           6.0         2.7
> > 85           5.4         3.0
> > 86           6.0         3.4
> > 87           6.7         3.1
> > 88           6.3         2.3
> > 89           5.6         3.0
> > 90           5.5         2.5
> > 91           5.5         2.6
> > 92           6.1         3.0
> > 93           5.8         2.6
> > 94           5.0         2.3
> > 95           5.6         2.7
> > 96           5.7         3.0
> > 97           5.7         2.9
> > 98           6.2         2.9
> > 99           5.1         2.5
> > 100          5.7         2.8
> > 101          6.3         3.3
> > 102          5.8         2.7
> > 103          7.1         3.0
> > 104          6.3         2.9
> > 105          6.5         3.0
> > 106          7.6         3.0
> > 107          4.9         2.5
> > 108          7.3         2.9
> > 109          6.7         2.5
> > 110          7.2         3.6
> > 111          6.5         3.2
> > 112          6.4         2.7
> > 113          6.8         3.0
> > 114          5.7         2.5
> > 115          5.8         2.8
> > 116          6.4         3.2
> > 117          6.5         3.0
> > 118          7.7         3.8
> > 119          7.7         2.6
> > 120          6.0         2.2
> > 121          6.9         3.2
> > 122          5.6         2.8
> > 123          7.7         2.8
> > 124          6.3         2.7
> > 125          6.7         3.3
> > 126          7.2         3.2
> > 127          6.2         2.8
> > 128          6.1         3.0
> > 129          6.4         2.8
> > 130          7.2         3.0
> > 131          7.4         2.8
> > 132          7.9         3.8
> > 133          6.4         2.8
> > 134          6.3         2.8
> > 135          6.1         2.6
> > 136          7.7         3.0
> > 137          6.3         3.4
> > 138          6.4         3.1
> > 139          6.0         3.0
> > 140          6.9         3.1
> > 141          6.7         3.1
> > 142          6.9         3.1
> > 143          5.8         2.7
> > 144          6.8         3.2
> > 145          6.7         3.3
> > 146          6.7         3.0
> > 147          6.3         2.5
> > 148          6.5         3.0
> > 149          6.2         3.4
> > 150          5.9         3.0
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Adding a new variable
>
> We want to add a variable called "Petal.Color" the `iris` data frame to record a new set of 
> observations. Lets first define a new data frame 'iris.update' (so as not to modify our original raw data).
> 
> 
> ~~~
> iris.update = iris
> ~~~
> {: .language-r}
> 
> Now, to initialize the variable, add a new character column to your data frame populated with
> no values to indicate that we have not recorded any observations.
> 
> > ## Solution
> > 
> > We have a couple of options:
> > 
> > 1) Define the vector and append it to the data frame using `cbind()`:
> > 
> > 
> > ~~~
> > Petal.Color = character(length = dim(iris.update)[1]) # use the dim function to figure out how long to make the new vector
> > iris.update = cbind(iris.update, Petal.Color)
> > head(iris.update)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Petal.Color
> > 1          5.1         3.5          1.4         0.2  setosa            
> > 2          4.9         3.0          1.4         0.2  setosa            
> > 3          4.7         3.2          1.3         0.2  setosa            
> > 4          4.6         3.1          1.5         0.2  setosa            
> > 5          5.0         3.6          1.4         0.2  setosa            
> > 6          5.4         3.9          1.7         0.4  setosa            
> > ~~~
> > {: .output}
> > 2) Directly populate the new column while creating it:
> > 
> > 
> > ~~~
> > iris.update$Petal.Color = as.character("")
> > head(iris.update)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Petal.Color
> > 1          5.1         3.5          1.4         0.2  setosa            
> > 2          4.9         3.0          1.4         0.2  setosa            
> > 3          4.7         3.2          1.3         0.2  setosa            
> > 4          4.6         3.1          1.5         0.2  setosa            
> > 5          5.0         3.6          1.4         0.2  setosa            
> > 6          5.4         3.9          1.7         0.4  setosa            
> > ~~~
> > {: .output}
> > 
> > There are also otherways to accomplish this task.
> {: .solution}
{: .challenge}

> ## Updating a Subset of Values
>
> Update the `iris.update` data frame by indicating that the "setosa" species had purple petals (without
> changing the values for the other species).
> 
> > ## Solution
> > 
> > ~~~
> > iris.update[iris.update$Species == "setosa", ]$Petal.Color <- "purple"
> > iris.update
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
> > 1            5.1         3.5          1.4         0.2     setosa
> > 2            4.9         3.0          1.4         0.2     setosa
> > 3            4.7         3.2          1.3         0.2     setosa
> > 4            4.6         3.1          1.5         0.2     setosa
> > 5            5.0         3.6          1.4         0.2     setosa
> > 6            5.4         3.9          1.7         0.4     setosa
> > 7            4.6         3.4          1.4         0.3     setosa
> > 8            5.0         3.4          1.5         0.2     setosa
> > 9            4.4         2.9          1.4         0.2     setosa
> > 10           4.9         3.1          1.5         0.1     setosa
> > 11           5.4         3.7          1.5         0.2     setosa
> > 12           4.8         3.4          1.6         0.2     setosa
> > 13           4.8         3.0          1.4         0.1     setosa
> > 14           4.3         3.0          1.1         0.1     setosa
> > 15           5.8         4.0          1.2         0.2     setosa
> > 16           5.7         4.4          1.5         0.4     setosa
> > 17           5.4         3.9          1.3         0.4     setosa
> > 18           5.1         3.5          1.4         0.3     setosa
> > 19           5.7         3.8          1.7         0.3     setosa
> > 20           5.1         3.8          1.5         0.3     setosa
> > 21           5.4         3.4          1.7         0.2     setosa
> > 22           5.1         3.7          1.5         0.4     setosa
> > 23           4.6         3.6          1.0         0.2     setosa
> > 24           5.1         3.3          1.7         0.5     setosa
> > 25           4.8         3.4          1.9         0.2     setosa
> > 26           5.0         3.0          1.6         0.2     setosa
> > 27           5.0         3.4          1.6         0.4     setosa
> > 28           5.2         3.5          1.5         0.2     setosa
> > 29           5.2         3.4          1.4         0.2     setosa
> > 30           4.7         3.2          1.6         0.2     setosa
> > 31           4.8         3.1          1.6         0.2     setosa
> > 32           5.4         3.4          1.5         0.4     setosa
> > 33           5.2         4.1          1.5         0.1     setosa
> > 34           5.5         4.2          1.4         0.2     setosa
> > 35           4.9         3.1          1.5         0.2     setosa
> > 36           5.0         3.2          1.2         0.2     setosa
> > 37           5.5         3.5          1.3         0.2     setosa
> > 38           4.9         3.6          1.4         0.1     setosa
> > 39           4.4         3.0          1.3         0.2     setosa
> > 40           5.1         3.4          1.5         0.2     setosa
> > 41           5.0         3.5          1.3         0.3     setosa
> > 42           4.5         2.3          1.3         0.3     setosa
> > 43           4.4         3.2          1.3         0.2     setosa
> > 44           5.0         3.5          1.6         0.6     setosa
> > 45           5.1         3.8          1.9         0.4     setosa
> > 46           4.8         3.0          1.4         0.3     setosa
> > 47           5.1         3.8          1.6         0.2     setosa
> > 48           4.6         3.2          1.4         0.2     setosa
> > 49           5.3         3.7          1.5         0.2     setosa
> > 50           5.0         3.3          1.4         0.2     setosa
> > 51           7.0         3.2          4.7         1.4 versicolor
> > 52           6.4         3.2          4.5         1.5 versicolor
> > 53           6.9         3.1          4.9         1.5 versicolor
> > 54           5.5         2.3          4.0         1.3 versicolor
> > 55           6.5         2.8          4.6         1.5 versicolor
> > 56           5.7         2.8          4.5         1.3 versicolor
> > 57           6.3         3.3          4.7         1.6 versicolor
> > 58           4.9         2.4          3.3         1.0 versicolor
> > 59           6.6         2.9          4.6         1.3 versicolor
> > 60           5.2         2.7          3.9         1.4 versicolor
> > 61           5.0         2.0          3.5         1.0 versicolor
> > 62           5.9         3.0          4.2         1.5 versicolor
> > 63           6.0         2.2          4.0         1.0 versicolor
> > 64           6.1         2.9          4.7         1.4 versicolor
> > 65           5.6         2.9          3.6         1.3 versicolor
> > 66           6.7         3.1          4.4         1.4 versicolor
> > 67           5.6         3.0          4.5         1.5 versicolor
> > 68           5.8         2.7          4.1         1.0 versicolor
> > 69           6.2         2.2          4.5         1.5 versicolor
> > 70           5.6         2.5          3.9         1.1 versicolor
> > 71           5.9         3.2          4.8         1.8 versicolor
> > 72           6.1         2.8          4.0         1.3 versicolor
> > 73           6.3         2.5          4.9         1.5 versicolor
> > 74           6.1         2.8          4.7         1.2 versicolor
> > 75           6.4         2.9          4.3         1.3 versicolor
> > 76           6.6         3.0          4.4         1.4 versicolor
> > 77           6.8         2.8          4.8         1.4 versicolor
> > 78           6.7         3.0          5.0         1.7 versicolor
> > 79           6.0         2.9          4.5         1.5 versicolor
> > 80           5.7         2.6          3.5         1.0 versicolor
> > 81           5.5         2.4          3.8         1.1 versicolor
> > 82           5.5         2.4          3.7         1.0 versicolor
> > 83           5.8         2.7          3.9         1.2 versicolor
> > 84           6.0         2.7          5.1         1.6 versicolor
> > 85           5.4         3.0          4.5         1.5 versicolor
> > 86           6.0         3.4          4.5         1.6 versicolor
> > 87           6.7         3.1          4.7         1.5 versicolor
> > 88           6.3         2.3          4.4         1.3 versicolor
> > 89           5.6         3.0          4.1         1.3 versicolor
> > 90           5.5         2.5          4.0         1.3 versicolor
> > 91           5.5         2.6          4.4         1.2 versicolor
> > 92           6.1         3.0          4.6         1.4 versicolor
> > 93           5.8         2.6          4.0         1.2 versicolor
> > 94           5.0         2.3          3.3         1.0 versicolor
> > 95           5.6         2.7          4.2         1.3 versicolor
> > 96           5.7         3.0          4.2         1.2 versicolor
> > 97           5.7         2.9          4.2         1.3 versicolor
> > 98           6.2         2.9          4.3         1.3 versicolor
> > 99           5.1         2.5          3.0         1.1 versicolor
> > 100          5.7         2.8          4.1         1.3 versicolor
> > 101          6.3         3.3          6.0         2.5  virginica
> > 102          5.8         2.7          5.1         1.9  virginica
> > 103          7.1         3.0          5.9         2.1  virginica
> > 104          6.3         2.9          5.6         1.8  virginica
> > 105          6.5         3.0          5.8         2.2  virginica
> > 106          7.6         3.0          6.6         2.1  virginica
> > 107          4.9         2.5          4.5         1.7  virginica
> > 108          7.3         2.9          6.3         1.8  virginica
> > 109          6.7         2.5          5.8         1.8  virginica
> > 110          7.2         3.6          6.1         2.5  virginica
> > 111          6.5         3.2          5.1         2.0  virginica
> > 112          6.4         2.7          5.3         1.9  virginica
> > 113          6.8         3.0          5.5         2.1  virginica
> > 114          5.7         2.5          5.0         2.0  virginica
> > 115          5.8         2.8          5.1         2.4  virginica
> > 116          6.4         3.2          5.3         2.3  virginica
> > 117          6.5         3.0          5.5         1.8  virginica
> > 118          7.7         3.8          6.7         2.2  virginica
> > 119          7.7         2.6          6.9         2.3  virginica
> > 120          6.0         2.2          5.0         1.5  virginica
> > 121          6.9         3.2          5.7         2.3  virginica
> > 122          5.6         2.8          4.9         2.0  virginica
> > 123          7.7         2.8          6.7         2.0  virginica
> > 124          6.3         2.7          4.9         1.8  virginica
> > 125          6.7         3.3          5.7         2.1  virginica
> > 126          7.2         3.2          6.0         1.8  virginica
> > 127          6.2         2.8          4.8         1.8  virginica
> > 128          6.1         3.0          4.9         1.8  virginica
> > 129          6.4         2.8          5.6         2.1  virginica
> > 130          7.2         3.0          5.8         1.6  virginica
> > 131          7.4         2.8          6.1         1.9  virginica
> > 132          7.9         3.8          6.4         2.0  virginica
> > 133          6.4         2.8          5.6         2.2  virginica
> > 134          6.3         2.8          5.1         1.5  virginica
> > 135          6.1         2.6          5.6         1.4  virginica
> > 136          7.7         3.0          6.1         2.3  virginica
> > 137          6.3         3.4          5.6         2.4  virginica
> > 138          6.4         3.1          5.5         1.8  virginica
> > 139          6.0         3.0          4.8         1.8  virginica
> > 140          6.9         3.1          5.4         2.1  virginica
> > 141          6.7         3.1          5.6         2.4  virginica
> > 142          6.9         3.1          5.1         2.3  virginica
> > 143          5.8         2.7          5.1         1.9  virginica
> > 144          6.8         3.2          5.9         2.3  virginica
> > 145          6.7         3.3          5.7         2.5  virginica
> > 146          6.7         3.0          5.2         2.3  virginica
> > 147          6.3         2.5          5.0         1.9  virginica
> > 148          6.5         3.0          5.2         2.0  virginica
> > 149          6.2         3.4          5.4         2.3  virginica
> > 150          5.9         3.0          5.1         1.8  virginica
> >     Petal.Color
> > 1        purple
> > 2        purple
> > 3        purple
> > 4        purple
> > 5        purple
> > 6        purple
> > 7        purple
> > 8        purple
> > 9        purple
> > 10       purple
> > 11       purple
> > 12       purple
> > 13       purple
> > 14       purple
> > 15       purple
> > 16       purple
> > 17       purple
> > 18       purple
> > 19       purple
> > 20       purple
> > 21       purple
> > 22       purple
> > 23       purple
> > 24       purple
> > 25       purple
> > 26       purple
> > 27       purple
> > 28       purple
> > 29       purple
> > 30       purple
> > 31       purple
> > 32       purple
> > 33       purple
> > 34       purple
> > 35       purple
> > 36       purple
> > 37       purple
> > 38       purple
> > 39       purple
> > 40       purple
> > 41       purple
> > 42       purple
> > 43       purple
> > 44       purple
> > 45       purple
> > 46       purple
> > 47       purple
> > 48       purple
> > 49       purple
> > 50       purple
> > 51             
> > 52             
> > 53             
> > 54             
> > 55             
> > 56             
> > 57             
> > 58             
> > 59             
> > 60             
> > 61             
> > 62             
> > 63             
> > 64             
> > 65             
> > 66             
> > 67             
> > 68             
> > 69             
> > 70             
> > 71             
> > 72             
> > 73             
> > 74             
> > 75             
> > 76             
> > 77             
> > 78             
> > 79             
> > 80             
> > 81             
> > 82             
> > 83             
> > 84             
> > 85             
> > 86             
> > 87             
> > 88             
> > 89             
> > 90             
> > 91             
> > 92             
> > 93             
> > 94             
> > 95             
> > 96             
> > 97             
> > 98             
> > 99             
> > 100            
> > 101            
> > 102            
> > 103            
> > 104            
> > 105            
> > 106            
> > 107            
> > 108            
> > 109            
> > 110            
> > 111            
> > 112            
> > 113            
> > 114            
> > 115            
> > 116            
> > 117            
> > 118            
> > 119            
> > 120            
> > 121            
> > 122            
> > 123            
> > 124            
> > 125            
> > 126            
> > 127            
> > 128            
> > 129            
> > 130            
> > 131            
> > 132            
> > 133            
> > 134            
> > 135            
> > 136            
> > 137            
> > 138            
> > 139            
> > 140            
> > 141            
> > 142            
> > 143            
> > 144            
> > 145            
> > 146            
> > 147            
> > 148            
> > 149            
> > 150            
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}



{% include links.md %}
