---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 02-class-R-data-types-structures.md in _episodes_rmd/
title: "Basic Data Types and Data Structures in R"
classdate: "8/28/2020 -- In Class"
teaching: 90
exercises: 30
questions:
- "What are the most common data types in R?"
- "What are the basic data structures in R?"
- "How do I access data within the basic data structures?"
objectives:
- "Understand the most commonly encountered data types in R and how these data types are used in data structures."
- "Create and manipulate vectors and matrices of different types."
- "Check the data type of a variable, vector, or matrix."
- "Understand the structure and properties of basic data structures (vectors and matrices)."
keypoints:
- "The most commonly encountered data types in R are character, numeric, and logical."
- "R's basic data structures are vectors and matrices."
- "Objects may have attributes, such as name, dimension, and class."
- "Use `object[x]` and `object[x, y]` to select a single element from a 2- and 3-dimensional data structure, respectively."
- "Use `from:to` to specify a sequence that includes the indices from `from` to `to`."
source: Rmd
---



***
## In Class

### Basic Data Types in R

R uses a variety of data types, which define the properties of the value stored in a variable. The three data types that you will use most commonly are **character** (text strings), **logical** (TRUE/FALSE values), and **numeric** (decimal or "double" numeric values) objects. For the most part, the data type of a variable is detected by the format of the value assigned:


~~~
char1 <- "hello!"
num1 <- 20.5
logic1 <- TRUE
~~~
{: .language-r}

&nbsp;

Use the `class()` function to determine the of a variable:


~~~
class(char1)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
class(num1)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}



~~~
class(logic1)
~~~
{: .language-r}



~~~
[1] "logical"
~~~
{: .output}

&nbsp;

You can shift between data types using the `as` functions:


~~~
num1.as.char <- as.character(num1)
num1.as.char
~~~
{: .language-r}



~~~
[1] "20.5"
~~~
{: .output}



~~~
# ... now check the class of the new variable:
class(num1.as.char)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
# you can't add numbers to characters!
num1.as.char + 4
~~~
{: .language-r}



~~~
Error in num1.as.char + 4: non-numeric argument to binary operator
~~~
{: .error}

&nbsp;

It only works if the conversion makes sense in context. R also does not understand
non-numeric references to numbers (e.g. using "two" to refer to the number 2):


~~~
# this one works:
as.numeric("44")
~~~
{: .language-r}



~~~
[1] 44
~~~
{: .output}



~~~
# these don't
as.numeric("hello!")
~~~
{: .language-r}



~~~
Warning: NAs introduced by coercion
~~~
{: .error}



~~~
[1] NA
~~~
{: .output}



~~~
as.numeric("forty-four")
~~~
{: .language-r}



~~~
Warning: NAs introduced by coercion
~~~
{: .error}



~~~
[1] NA
~~~
{: .output}

&nbsp;

Note that when one of the `as.` functions throws an error, it doesn't simply fail to return a variable. Instead it throws an error message and assigns an `NA` value to the variable. `NA` is one of several special values that represents missing data, or "Not Available". You will explore these special characters in more detail *On Your Own*.

The `as.logical()` function will take `0` as `FALSE` and any non-zero numeric as `TRUE`. It will throw an error for any character input that is a common spelling of `TRUE` or `FALSE`. Note that `T` works, but `t` does not.


~~~
as.logical(0)
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}



~~~
as.logical(1)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical(10)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical(0.01)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical(-4)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical("TRUE")
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical("True")
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical("tRUE")
~~~
{: .language-r}



~~~
[1] NA
~~~
{: .output}



~~~
as.logical("T")
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical("t")
~~~
{: .language-r}



~~~
[1] NA
~~~
{: .output}



~~~
as.logical("false")
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}
&nbsp;
### Data Structures in R


***
### Vectors

A vector is the most common and basic data structure in R. Vectors are also the major workhorse data structure of R. Technically, vectors can be one of two types:

* atomic vectors
* lists

However, the term "vector" most commonly refers to the atomic types and not to lists. Here we will examine atomic vectors (hereafter just called "vectors"). Lists have a critical place R as well, and will be the topic of a future lesson.

&nbsp;
#### The Different Vector Modes

A vector is a collection of elements that are most commonly of mode `character`,
`logical`, `integer` or `numeric`.

You can create an empty vector with the `vector()` function. By default, the mode is `logical`, but you can be more explicit using additional arguments, as shown in the examples below. A simpler solution is to just directly construct vectors of the desired mode using on of several available functions, such as `character()`, `numeric()`, etc.


~~~
vector() # an empty 'logical' (the default) vector
~~~
{: .language-r}



~~~
logical(0)
~~~
{: .output}



~~~
vector("character", length = 5) # a vector of mode 'character' with 5 elements
~~~
{: .language-r}



~~~
[1] "" "" "" "" ""
~~~
{: .output}



~~~
character(5) # the same thing, but using the direct constructor function
~~~
{: .language-r}



~~~
[1] "" "" "" "" ""
~~~
{: .output}



~~~
numeric(5)   # a numeric vector with 5 elements
~~~
{: .language-r}



~~~
[1] 0 0 0 0 0
~~~
{: .output}



~~~
logical(5)   # a logical vector with 5 elements
~~~
{: .language-r}



~~~
[1] FALSE FALSE FALSE FALSE FALSE
~~~
{: .output}

&nbsp;

You can also create vectors by directly specifying their content. R will then guess the appropriate mode of storage for the vector based on your input data. To do this, you use the function `c()` (which stands for "combine"):


~~~
# numeric vector
x <- c(1, 2, 3)
class(x)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}

&nbsp;

The `c()` function is the most common way to define a vector of objects for manipulation. Directly specifying `TRUE` and `FALSE` will create a vector of mode `logical`:


~~~
y <- c(TRUE, TRUE, FALSE, FALSE)
class(y)
~~~
{: .language-r}



~~~
[1] "logical"
~~~
{: .output}

&nbsp;

While quoted text will create a vector of mode `character`:


~~~
z <- c("Sarah", "Tracy", "Jon")
class(z)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
# adding quotes to numbers forces a character vector
x.char <- c("1", "2", "3")
class(x.char)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}

&nbsp;
#### Adding Elements

The function `c()` can also be used to add elements to a vector:


~~~
z <- c(z, "Annette")
z
~~~
{: .language-r}



~~~
[1] "Sarah"   "Tracy"   "Jon"     "Annette"
~~~
{: .output}



~~~
z <- c("Greg", z)
z
~~~
{: .language-r}



~~~
[1] "Greg"    "Sarah"   "Tracy"   "Jon"     "Annette"
~~~
{: .output}

&nbsp;

Note that order matters and defines the order in the output vector. `c()` treats any argument that is a vector as just another set of elements in the list.

&nbsp;
#### Vectors from a Sequence of Numbers

Use the `seq()` function or the `:` operator to create a vector as a sequence of numbers.


~~~
seq(10)
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
1:10
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
seq(from = 1, to = 10, by = 0.1)
~~~
{: .language-r}



~~~
 [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4
[16]  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9
[31]  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4
[46]  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9
[61]  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4
[76]  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9
[91] 10.0
~~~
{: .output}

&nbsp;

You can assign these sequences directly to a variable:


~~~
series1 <- 5:15
series1
~~~
{: .language-r}



~~~
 [1]  5  6  7  8  9 10 11 12 13 14 15
~~~
{: .output}



~~~
series2 <- seq(from = 3, to = 8, by = 0.2)
series2
~~~
{: .language-r}



~~~
 [1] 3.0 3.2 3.4 3.6 3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6
[20] 6.8 7.0 7.2 7.4 7.6 7.8 8.0
~~~
{: .output}

&nbsp;
#### What happens when you mix types inside a vector?

R will create a resulting vector with a mode that can most easily accommodate
all the elements it contains (similar to using the `as.` functions). This conversion between modes of storage is called "coercion". When R converts the mode of storage based on its content, it is referred to as "implicit coercion". 

> ## Mixing data types in vectors
> 
> What the do you think the following will do (without running them first)?
> 
> 
> ~~~
> z1 <- c(1.7, "a")
> z2 <- c(TRUE, 2)
> z3 <- c("a", TRUE)
> ~~~
> {: .language-r}
> > ## Solution
> > 
> > 
> > ~~~
> > z1 <- c(1.7, "a") 
> > class(z1)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "character"
> > ~~~
> > {: .output}
> > `z1` is forced to be a character vector. `"1.7"` can be a character, while 
> > `"a"` cannot be a number.
> > 
> > 
> > ~~~
> > z2 <- c(TRUE, 2) 
> > class(z2)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "numeric"
> > ~~~
> > {: .output}
> > `z2` is forced to be a numeric vector. `TRUE` can be interpreted as a number 
> > (`TRUE` = `1`, `FALSE` = `0`), while `2` cannot be interpreted as a logical 
> > value (or can it?)
> > 
> > 
> > ~~~
> > z3 <- c("a", TRUE)
> > class(z3)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "character"
> > ~~~
> > {: .output}
> > `z3` is forced to be a character vector. `"TRUE"` can be a character, while 
> > `"a"` cannot be interpreted as a logical value
> > 
> {: .solution}
{: .challenge}

&nbsp;

> ## Finding commonalities
>
> What two properties are common to all of the vectors above?
> > ## Solution
> > Properties of vectors:
> > * All vectors are one-dimensional
> > * Each vector element is of the same type.
> {: .solution}
{: .challenge}

&nbsp;
#### Indexing vectors

In R, `[]` are used to index vectors and other objects. For vectors, the number entered in the `[n]` will return the nth element of the vector.


~~~
x = c("a","b","c","d","e","f")
x
~~~
{: .language-r}



~~~
[1] "a" "b" "c" "d" "e" "f"
~~~
{: .output}



~~~
x[5]
~~~
{: .language-r}



~~~
[1] "e"
~~~
{: .output}

&nbsp;

You can also use pre-defined variables or even other vectors to index different parts of the vector:


~~~
n = 6
range = 2:4

x[n] # returns the 6th element, as defined by n = 6
~~~
{: .language-r}



~~~
[1] "f"
~~~
{: .output}



~~~
x[range] # returns the range of values specified by "range", in this case elements 2 to 4.
~~~
{: .language-r}



~~~
[1] "b" "c" "d"
~~~
{: .output}

> ## Subsetting data
>
> Let's look at a different subsetting option using a character vectors:
>
> 
> ~~~
> animal <- c("m", "o", "n", "k", "e", "y")
> 
> # first three characters
> animal[1:3]
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
> [1] "m" "o" "n"
> ~~~
> {: .output}
> 
> 
> 
> ~~~
> # last three characters
> animal[4:6]
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
> [1] "k" "e" "y"
> ~~~
> {: .output}
>
> &nbsp;
>
> Consider the following questions:
>
> 1.  If the first four characters are selected using the subset `animal[1:4]`, 
> how can we obtain the first four characters in reverse order?
>
> 2. What output results from `animal[-1]`?
> 
> 3. What ouptut results from `animal[-4]`?
>
> 4. Given 1-3, what do you expect `animal[-1:-4]` to produce?
>
> 5. Use a subset of the `animal` vector to create a new character vector that spells the word "main", i.e. `c("m", "a", "i", "n")`.
>
> > ## Solutions
> > 
> > 1. `animal[4:1]`
> > 
> > 2. `"o" "n" "k" "e" "y"`
> > 
> > 3. `"m" "o" "n" "e" "y"`, which means that a single `-` removes the element 
> > at the given index position.
> > 
> > 4. `animal[-1:-4]` remove the subset at indexes 1 to 4, returning `"e" "y"`,
> > which is equivalent to `animal[5:6]`.
> > 
> > 
> > ~~~
> > animal[-1:-4]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "e" "y"
> > ~~~
> > {: .output}
> > 
> > 
> > 
> > ~~~
> > animal[5:6]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "e" "y"
> > ~~~
> > {: .output}
> > 
> > 5. `animal[c(5,2,3)]` combines indexing with the `c`ombine function to 
> > spell the word "eon" in a new vector:
> > 
> > 
> > ~~~
> > animal[c(5,2,3)]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "e" "o" "n"
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

&nbsp;

We will talk about more advanced indexing strategies later in the course.

&nbsp;
#### Vectorized operations

R has a special way of dealing with vectors when dealing with operations. We know what to expect from `1 + 1`, but what happens if you try to add two vectors?


~~~
x = c(1,2,3)
y = c(4,5,6)

z = x + y
z
~~~
{: .language-r}



~~~
[1] 5 7 9
~~~
{: .output}

&nbsp;

R creates a new vector in which each element the sum of the elements with the same index from x and y. In essence, R is performing 3 separate "addition" operations and combining the results into a new vector. We can mimick this behavior manually:


~~~
z1 = x[1] + y[1]
z2 = x[2] + y[2]
z3 = x[3] + y[3]

z = c(z1, z2, z3)
z
~~~
{: .language-r}



~~~
[1] 5 7 9
~~~
{: .output}

&nbsp;

This process is called "vectorization". It works for most mathematical operations:

~~~
x - y
~~~
{: .language-r}



~~~
[1] -3 -3 -3
~~~
{: .output}



~~~
x * y
~~~
{: .language-r}



~~~
[1]  4 10 18
~~~
{: .output}



~~~
x / y
~~~
{: .language-r}



~~~
[1] 0.25 0.40 0.50
~~~
{: .output}



~~~
x ^ y
~~~
{: .language-r}



~~~
[1]   1  32 729
~~~
{: .output}

&nbsp;

Many functions also behave in a vectorized manner. Take the `paste()` function, for example, which combines two or more character variables into a single variable:


~~~
# Here is the output with two strings
paste("I like", "dogs.")
~~~
{: .language-r}



~~~
[1] "I like dogs."
~~~
{: .output}



~~~
# Now let's try pasting two character vectors together:
attitude <- c("I like","I dislike","I am indifferent to")
animal <-  c("dogs.","fish.","cats.")

paste(attitude,animal)
~~~
{: .language-r}



~~~
[1] "I like dogs."              "I dislike fish."          
[3] "I am indifferent to cats."
~~~
{: .output}

&nbsp;

Depending on how they are written and the way their input/output works, some functions may not act on the vector, but on the list of values in the vector. The best way to find out is to just give it a try. 


***
### Objects Attributes

R objects can have **attributes**. Attributes are metadata and part of the object. Each attribute describes a different aspect of the object. These include:

* **names** -- some objects (e.g. lists) have named elements
* **dim** -- the number of rows and columns in a matrix
* **class** -- the data type of an object
* **attributes** -- a list containing other forms of metadata of more complex objects

While technically not assigned *attributes*, you can also glean other attribute-like metadata information from objects such as length (works on vectors and lists) or number of characters (for character strings).


~~~
length(1:10)
~~~
{: .language-r}



~~~
[1] 10
~~~
{: .output}



~~~
nchar("MCB 585")
~~~
{: .language-r}



~~~
[1] 7
~~~
{: .output}

&nbsp;

We will periodically use object attributes to manipulate objects throughout the course.

***
### Matrices

In R matrices are an extension of vectors. They are not a separate type of object but simply an atomic vector with dimensions; the number of rows and columns. As with atomic vectors, the elements of a matrix must be of the same data type. Like vectors, we can use the generic `matrix()` function to build a matrix. Unlike vectors, there is no direct equivalent for each data type (e.g. `character()`):


~~~
# first create a vector, then coerce that vector into a matrix:
v <- 1:4
m <- matrix(data = v, nrow = 2, ncol = 2)

# note the difference in structure
v
~~~
{: .language-r}



~~~
[1] 1 2 3 4
~~~
{: .output}



~~~
m
~~~
{: .language-r}



~~~
     [,1] [,2]
[1,]    1    3
[2,]    2    4
~~~
{: .output}

&nbsp;

We can no examine some of the attributes of our new matrix `m`:


~~~
dim(m)
~~~
{: .language-r}



~~~
[1] 2 2
~~~
{: .output}



~~~
attributes(m)
~~~
{: .language-r}



~~~
$dim
[1] 2 2
~~~
{: .output}

&nbsp; 

Note that under the surface, R still treats `m` as a vector, so the `length()` of `v` and `m` are the same (i.e. both contain 4 elements):


~~~
length(v)
~~~
{: .language-r}



~~~
[1] 4
~~~
{: .output}



~~~
length(m)
~~~
{: .language-r}



~~~
[1] 4
~~~
{: .output}

&nbsp;

Matrices are a higher-oder object (a vector with additional properties). Thus the `class()` function no longer tells you the data type for each element, but rather the data structure type of the entire object:


~~~
class(m)
~~~
{: .language-r}



~~~
[1] "matrix" "array" 
~~~
{: .output}

&nbsp;

You can check the data type of the elements of the matrix using `typeof()`:


~~~
typeof(m)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

&nbsp;

While `class()` shows that m is a matrix, `typeof()` shows that fundamentally the
matrix is an integer vector.

Note that one difference between vectors and matrices is that an otherwise identical vector will return the data type of each element when you use `class()`, while the matrix is a new type of object with `class()` "matrix".

> ## Data types of matrix elements
> 
> Consider the following matrix:
> 
> 
> ~~~
> FOURS <- matrix(
>   c(4, 4, 4, 4),
>   nrow = 2,
>   ncol = 2)
> ~~~
> {: .language-r}
>
> Given that `typeof(FOURS[1])` returns `"double"`, what would you expect
> `typeof(FOURS)` to return? How do you know this is the case even without
> running this code?
>
> > ## Solution
> > We know that `typeof(FOURS)` will also return `"double"` since matrices 
> > are just vectors, and vectors must be made of elements of the same data
> > type. Note that you could do something like `as.character(FOURS)` if you
> > needed the elements of `FOURS` to be *characters*.
> {: .solution}
{: .challenge}

&nbsp;

By default, matrices in R are filled column-wise:


~~~
m1 <- matrix(1:6, nrow = 2, ncol = 3)
m1
~~~
{: .language-r}



~~~
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
~~~
{: .output}

... unless you tell it to fill by row explicitly using the `byrow` argument:


~~~
m2 <- matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)
m2
~~~
{: .language-r}



~~~
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
~~~
{: .output}

&nbsp;

Other ways to construct a matrix


~~~
m <- 1:10

# so far m is just a vector!
m
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
class(m)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}



~~~
# defining the "dimensions" attribute automatically converts m to a matrix
dim(m) <- c(2, 5)
m
~~~
{: .language-r}



~~~
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10
~~~
{: .output}



~~~
class(m)
~~~
{: .language-r}



~~~
[1] "matrix" "array" 
~~~
{: .output}

&nbsp;

This takes a vector and transforms it into a matrix with 2 rows and 5 columns.

Another way is to bind columns or rows using `rbind()` and `cbind()` ("row bind"
and "column bind", respectively).


~~~
x <- 1:3
y <- 10:12
cbind(x, y)
~~~
{: .language-r}



~~~
     x  y
[1,] 1 10
[2,] 2 11
[3,] 3 12
~~~
{: .output}



~~~
rbind(x, y)
~~~
{: .language-r}



~~~
  [,1] [,2] [,3]
x    1    2    3
y   10   11   12
~~~
{: .output}

&nbsp;
#### Indexing matrices

Like vectors, `[]` are used to index matrices. Since matrices are, by definition, two-dimensional, use `[m,n]` to index the *m*th row and *n*th column of a matrix. The row is always specified before the `,` and the column after.


~~~
m <- matrix(1:10, nrow = 2, ncol = 5)
m
~~~
{: .language-r}



~~~
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10
~~~
{: .output}



~~~
m[2, 3]
~~~
{: .language-r}



~~~
[1] 6
~~~
{: .output}

&nbsp;

If you are only interested in indexing a specific row, but do not want to change the columns, you can just leave the column index blank (but don't forget the `,`!):


~~~
m[2,]
~~~
{: .language-r}



~~~
[1]  2  4  6  8 10
~~~
{: .output}


> ## Subsetting data
>
> Let's look at a different ways to manipulate matrices. First, let's define
> a simple matrix to play with:
>
> 
> ~~~
> m <- matrix(1:12, nrow=3)
> m
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
>      [,1] [,2] [,3] [,4]
> [1,]    1    4    7   10
> [2,]    2    5    8   11
> [3,]    3    6    9   12
> ~~~
> {: .output}
>
> &nbsp;
>
> Keeping in mind what you know about the behavior of vectors, consider the  
> following questions:
>
> 1. How can you use indexing to extract the middle of the matrix (e.g. `5` 
> and `8`)?
>
> 2. What output do you expect from `m[-2,]`?
>
> 3. What output do you expect from `m[,2:3]`?
> 
> 4. What result do expect when you try including `m` in simple 
> multiplication: `2*m`?
>
> 5. Can you predict what will happen if you try `m[,c(1,3)]`?
>
> 6. There is a useful function `t()`. Try `t(m)`. Based on the output,
> what does `t()` do? What do you think the `t` stands for?
>
> 7. What happens if we only ask for a single index (`m[4]`)? 
> 
> > ## Solutions
> > 
> > 1. The numbers `5` and `8` appear in the second row, and the second and third > > columns, respectively. To extract this matrix subset, we use the index:
> >
> > 
> > ~~~
> > m[2,2:3]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] 5 8
> > ~~~
> > {: .output}
> > 
> > &nbsp;
> >
> > {:start="2"}
> > 2. Like in vectors, the `-` tells R to exclude the index that follows. In 
> > this case, exclude row 2. The column index is blank, so all columns are 
> > returned. Thus we end up with a smaller matrix with only rows 1 and 3, and 
> > all elements in row 2 removed:
> >
> > 
> > ~~~
> >      [,1] [,2] [,3] [,4]
> > [1,]    1    4    7   10
> > [2,]    3    6    9   12
> > ~~~
> > {: .output}
> > 
> > &nbsp;
> >
> > {:start="3"}
> > 3. As with vectors, including a set of sequential values in either index
> > will return all of the indexes in that range. In this case rows are blank
> > (so include all rows), and columns 2-3 are requested, so we will get the 
> > following 2x2 matrix:
> >
> > 
> > ~~~
> >      [,1] [,2]
> > [1,]    4    7
> > [2,]    5    8
> > [3,]    6    9
> > ~~~
> > {: .output}
> >  
> > &nbsp;
> >
> > {:start="4"}
> > 4. Because matrices are essentially vectors with attributes, all standard
> > operations are "vectorized". We thus expect a new matrix with the same 
> > dimensions as m, but with each element equal to twice the corresponding 
> > element in m:
> > 
> > 
> > ~~~
> >      [,1] [,2] [,3] [,4]
> > [1,]    2    8   14   20
> > [2,]    4   10   16   22
> > [3,]    6   12   18   24
> > ~~~
> > {: .output}
> > 
> > &nbsp;
> >
> > {:start="5"}
> > 5. While we haven't covered it explicity, entering `2:3` into an index
> > (like in question 3) is equivalent to entering an list of values (e.g. 
> > `c(2,3)`). Any list of this sort can be used to index a specific (and 
> > not necessarily sequential) set of rows or columns. Thus we expect 
> > the list `c(1,3)` entered into the column index to return columns 1 and 3:
> > 
> > 
> > ~~~
> >      [,1] [,2]
> > [1,]    1    7
> > [2,]    2    8
> > [3,]    3    9
> > ~~~
> > {: .output}
> > 
> > &nbsp;
> >
> > {:start="6"}
> > 6. Let's see what happens if we use the `t()` function on `m`:
> > 
> > 
> > ~~~
> > t(m)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >      [,1] [,2] [,3]
> > [1,]    1    2    3
> > [2,]    4    5    6
> > [3,]    7    8    9
> > [4,]   10   11   12
> > ~~~
> > {: .output}
> > 
> > &nbsp;
> > 
> > The `t` stands for "transpose", and as we can see from the result, `t(m)`
> > simply "flips" the matrix so that rows are now columns and columns are now
> > rows.
> > 
> > &nbsp;
> > 
> > {:start="7"}
> > 7. Since a matrix is just a fancy vector, requesting R to return the 4th
> > index (`m[4]`) will simply return the 4th value in the underlying vector:
> > 
> > 
> > ~~~
> > [1] 4
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

&nbsp;

What if we ask for an index outside the range of a matrix?


~~~
m[3,15]
~~~
{: .language-r}



~~~
Error in m[3, 15]: subscript out of bounds
~~~
{: .error}

&nbsp;

This error universally occurs whenever you request an invalid index to an object in R (vector, matrix, list, data frame, etc.)

***

{% include links.md %}
