---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 02-class-R-data-types-structures.md in _episodes_rmd/
title: "Basic Data Types and Data Structures in R"
classdate: "8/28/2020 -- In Class"
teaching: 90
exercises: 30
questions:
- "What are the most common data types in R?"
- "What are the basic data structures in R?"
- "How do I access data within the basic data structures?"
objectives:
- "Understand the most commonly encountered data types in R and how these data types are used in data structures."
- "Create and manipulate vectors and matrices of different types."
- "Check the data type of a variable, vector, or matrix."
- "Understand the structure and properties of basic data structures (vectors and matrices)."
keypoints:
- "The most commonly encountered data types in R are character, numeric, and logical."
- "R's basic data structures are vectors and matrices."
- "Objects may have attributes, such as name, dimension, and class."
- "Use `object[x]` and `object[x, y]` to select a single element from a 2- and 3-dimensional data structure, respectively."
- "Use `from:to` to specify a sequence that includes the indices from `from` to `to`."
source: Rmd
---



***
## In Class

&nbsp;
### Basic Data Types in R

R uses a variety of data types, which define the properties of the value stored in a variable. The three data types that you will use most commonly are **character** (text strings), **logical** (TRUE/FALSE values), and **numeric** (decimal or "double" numeric values) objects. For the most part, the data type of a variable is detected by the format of the value assigned:


~~~
char1 <- "hello!"
num1 <- 20.5
logic1 <- TRUE
~~~
{: .language-r}

&nbsp;

Use the `class` function to determine the of a variable:


~~~
class(char1)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
class(num1)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}



~~~
class(logic1)
~~~
{: .language-r}



~~~
[1] "logical"
~~~
{: .output}

You can shift between data types using the `as` functions:

~~~
num1.as.char <- as.character(num1)
class(num.as.char)
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'num.as.char' not found
~~~
{: .error}



~~~
# you can't add numbers to characters!
num1.as.char + 4
~~~
{: .language-r}



~~~
Error in num1.as.char + 4: non-numeric argument to binary operator
~~~
{: .error}

&nbsp;

It only works if the conversion makes sense in context. R also does not understand
non-numeric references to numbers (e.g. using "two" to refer to the number 2):


~~~
# this one works:
as.numeric("44")
~~~
{: .language-r}



~~~
[1] 44
~~~
{: .output}



~~~
# these don't
as.numeric("hello!")
~~~
{: .language-r}



~~~
Warning: NAs introduced by coercion
~~~
{: .error}



~~~
[1] NA
~~~
{: .output}



~~~
as.numeric("forty-four")
~~~
{: .language-r}



~~~
Warning: NAs introduced by coercion
~~~
{: .error}



~~~
[1] NA
~~~
{: .output}

&nbsp;
### Data Structures in R


***
### Vectors

A vector is the most common and basic data structure in R. Vectors are the
workhorse data struture of R. Technically, vectors can be one of two types:

* atomic vectors
* lists

although the term "vector" most commonly refers to the atomic types not to lists.

&nbsp;
#### The Different Vector Modes

A vector is a collection of elements that are most commonly of mode `character`,
`logical`, `integer` or `numeric`.

You can create an empty vector with `vector()`. (By default the mode is
`logical`. You can be more explicit as shown in the examples below.) It is more
common to use direct constructors such as `character()`, `numeric()`, etc.


~~~
vector() # an empty 'logical' (the default) vector
~~~
{: .language-r}



~~~
logical(0)
~~~
{: .output}



~~~
vector("character", length = 5) # a vector of mode 'character' with 5 elements
~~~
{: .language-r}



~~~
[1] "" "" "" "" ""
~~~
{: .output}



~~~
character(5) # the same thing, but using the constructor directly
~~~
{: .language-r}



~~~
[1] "" "" "" "" ""
~~~
{: .output}



~~~
numeric(5)   # a numeric vector with 5 elements
~~~
{: .language-r}



~~~
[1] 0 0 0 0 0
~~~
{: .output}



~~~
logical(5)   # a logical vector with 5 elements
~~~
{: .language-r}



~~~
[1] FALSE FALSE FALSE FALSE FALSE
~~~
{: .output}

&nbsp;

You can also create vectors by directly specifying their content. R will then
guess the appropriate mode of storage for the vector. For instance:


~~~
x <- c(1, 2, 3)
typeof(x)
~~~
{: .language-r}



~~~
[1] "double"
~~~
{: .output}

&nbsp;

This will create a vector `x` of mode `numeric`. These are the most common kind, and
are treated as double precision real numbers. If you wanted to explicitly create
integers, you need to add an `L` to each element


~~~
x1 <- c(1L, 2L, 3L)
typeof(x1)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

&nbsp;

You can also *coerce* a vector to the integer type using `as.integer()`.


~~~
x2 <- as.integer(x)
typeof(x2)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

&nbsp;

Directly specifying `TRUE` and `FALSE` will create a vector of mode `logical`:


~~~
y <- c(TRUE, TRUE, FALSE, FALSE)
typeof(y)
~~~
{: .language-r}



~~~
[1] "logical"
~~~
{: .output}

&nbsp;

While quoted text will create a vector of mode `character`:


~~~
z <- c("Sarah", "Tracy", "Jon")
typeof(z)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}

&nbsp;
#### Examining Vectors

The functions `typeof()`, `length()`, `class()` and `str()` provide useful
information about your vectors and R objects in general.


~~~
typeof(z)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
length(z)
~~~
{: .language-r}



~~~
[1] 3
~~~
{: .output}



~~~
class(z)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
str(z) # stands for "structure" of an object
~~~
{: .language-r}



~~~
 chr [1:3] "Sarah" "Tracy" "Jon"
~~~
{: .output}

&nbsp;
#### Adding Elements

The function `c()` (for combine) can also be used to add elements to a vector.


~~~
z <- c(z, "Annette")
z
~~~
{: .language-r}



~~~
[1] "Sarah"   "Tracy"   "Jon"     "Annette"
~~~
{: .output}



~~~
z <- c("Greg", z)
z
~~~
{: .language-r}



~~~
[1] "Greg"    "Sarah"   "Tracy"   "Jon"     "Annette"
~~~
{: .output}

&nbsp;
#### Vectors from a Sequence of Numbers

Use the `seq()` function or the `:` operator to create a vector as a sequence of numbers.


~~~
seq(10)
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
1:10
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
seq(from = 1, to = 10, by = 0.1)
~~~
{: .language-r}



~~~
 [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4
[16]  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9
[31]  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4
[46]  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9
[61]  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4
[76]  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9
[91] 10.0
~~~
{: .output}

&nbsp;
You can assign the sequence directly to a variable:

~~~
series1 = 5:15
series2 = seq(from = 3, to = 8, by = 0.2)
~~~
{: .language-r}

&nbsp;
#### What Happens When You Mix Types Inside a Vector?

R will create a resulting vector with a mode that can most easily accommodate
all the elements it contains. This conversion between modes of storage is called
"coercion". When R converts the mode of storage based on its content, it is
referred to as "implicit coercion". 

> ## Mixing data types in vectors
> 
> What the do you think the following will do (without running them first)?
> 
> 
> ~~~
> z1 <- c(1.7, "a")
> z2 <- c(TRUE, 2)
> z3 <- c("a", TRUE)
> ~~~
> {: .language-r}
> > ## Solution
> > 
> > 
> > ~~~
> > z1 <- c(1.7, "a") 
> > typeof(z1)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "character"
> > ~~~
> > {: .output}
> > `z1` is forced to be a character vector. `"1.7"` can be a character, while `"a"` cannot be a number.
> > 
> > 
> > ~~~
> > z2 <- c(TRUE, 2) 
> > typeof(z2)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "double"
> > ~~~
> > {: .output}
> > `z2` is forced to be a numeric vector. `TRUE` can be interpreted as a number (`TRUE` = `1`, `FALSE` = `0`), while `2` cannot be interpreted as a logical value (or can it?)
> > 
> > 
> > ~~~
> > z3 <- c("a", TRUE)
> > typeof(z3)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "character"
> > ~~~
> > {: .output}
> > `z3` is forced to be a character vector. `"TRUE"` can be a character, while `"a"` cannot be interpreted as a logical value
> > 
> {: .solution}
{: .challenge}

&nbsp;

You can also control how vectors are coerced explicitly using the
`as.[class_name]()` functions:


~~~
as.numeric("1")
~~~
{: .language-r}



~~~
[1] 1
~~~
{: .output}



~~~
as.character(1:2)
~~~
{: .language-r}



~~~
[1] "1" "2"
~~~
{: .output}

&nbsp;

In reality, all numeric and complex values can be interpreted logically:
* 0 = FALSE
* non-0 = TRUE

~~~
as.logical(0)
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}



~~~
as.logical(1)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical(4.2)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical(-5)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
as.logical(c(0+0i))
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}



~~~
as.logical(c(1+2i))
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}

&nbsp;

What if we try to force something that cannot be interpreted?


~~~
as.numeric("a")
~~~
{: .language-r}



~~~
Warning: NAs introduced by coercion
~~~
{: .error}



~~~
[1] NA
~~~
{: .output}

> ## Finding Commonalities
>
> What two properties are common to all of the vectors above?
> > ## Solution
> > Properties of vectors:
> > * All vectors are one-dimensional
> > * Each vector element is of the same type.
> {: .solution}
{: .challenge}

&nbsp;
#### Indexing vectors

In R, `[]` are used to index vectors and other objects. For vectors, the number entered in the `[n]` will return the nth element of the vector.


~~~
x = c("a","b","c","d","e","f")
x
~~~
{: .language-r}



~~~
[1] "a" "b" "c" "d" "e" "f"
~~~
{: .output}



~~~
x[5]
~~~
{: .language-r}



~~~
[1] "e"
~~~
{: .output}

&nbsp;

You can also use pre-defined variables or even other vectors to index different parts of the vector:


~~~
n = 6
range = 2:4

x[n] # returns the 6th element, as defined by n = 6
~~~
{: .language-r}



~~~
[1] "f"
~~~
{: .output}



~~~
x[range] # returns the range of values specified by "range", in this case elements 2 to 4.
~~~
{: .language-r}



~~~
[1] "b" "c" "d"
~~~
{: .output}

> ## Subsetting Data
>
> Let's look at a different subsetting option using a character vectors:
>
> 
> ~~~
> animal <- c("m", "o", "n", "k", "e", "y")
> # first three characters
> animal[1:3]
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
> [1] "m" "o" "n"
> ~~~
> {: .output}
> 
> 
> 
> ~~~
> # last three characters
> animal[4:6]
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
> [1] "k" "e" "y"
> ~~~
> {: .output}
>
> 1.  If the first four characters are selected using the subset `animal[1:4]`, how can we obtain the first four characters in reverse order?
>
> 1.  What is `animal[-1]`?
>    What is `animal[-4]`?
>    Given those answers,
>    explain what `animal[-1:-4]` does.
>
> 1.  Use a subset of `animal` to create a new character vector that spells the word "eon", i.e. `c("e", "o", "n")`.
> > ## Solutions
> > 
> > 1. `animal[4:1]`
> > 
> > 1. `"o" "n" "k" "e" "y"` and `"m" "o" "n" "e" "y"`, which means that a
> >    single `-` removes the element at the given index position.
> >    `animal[-1:-4]` remove the subset, returning `"e" "y"`, which is
> >    equivalent to `animal[5:6]`.
> > 
> > 1. `animal[c(5,2,3)]` combines indexing with the `c`ombine function.
> > 
> {: .solution}
{: .challenge}

&nbsp;

We will talk about more advanced indexing later in this lesson.

&nbsp;
#### Vectorized operations

R has a special way of dealing with vectors when dealing with operations. We know what to expect from `1 + 1`, but what happens if you try to add two vectors?

~~~
x = c(1,2,3)
y = c(4,5,6)

z = x + y
z
~~~
{: .language-r}



~~~
[1] 5 7 9
~~~
{: .output}

&nbsp;

R creates a new vector with each element the sum of the elements with the same index from x and y. In essence, R is performing 3 separate "addition" operations and combining the results into a new vector:

~~~
z1 = x[1] + y[1]
z2 = x[2] + y[2]
z3 = x[3] + y[3]

z = c(z1, z2, z3)
z
~~~
{: .language-r}



~~~
[1] 5 7 9
~~~
{: .output}

&nbsp;

This process is called "vectorization". It works for most mathematical operations:

~~~
x-y
~~~
{: .language-r}



~~~
[1] -3 -3 -3
~~~
{: .output}



~~~
x * y
~~~
{: .language-r}



~~~
[1]  4 10 18
~~~
{: .output}



~~~
x/y
~~~
{: .language-r}



~~~
[1] 0.25 0.40 0.50
~~~
{: .output}



~~~
x^y
~~~
{: .language-r}



~~~
[1]   1  32 729
~~~
{: .output}

&nbsp;

Many functions also behave in a vectorized manner. Take the `paste()` function, for example, which combines two or more character variables into a single variable:

~~~
# Here is the output with two strings
paste("I like", "dogs.")
~~~
{: .language-r}



~~~
[1] "I like dogs."
~~~
{: .output}



~~~
# Now let's try pasting two character vectors together:
attitude <- c("I like","I dislike","I am indifferent to")
animal <-  c("dogs.","fish.","cats.")

paste(attitude,animal)
~~~
{: .language-r}



~~~
[1] "I like dogs."              "I dislike fish."          
[3] "I am indifferent to cats."
~~~
{: .output}

&nbsp;

Depending on how they are written and the way their input/output works, some functions may not act on the vector, but on the list of values in the vector. The best way to find out is to give it a try. 

***
### Missing data and special values

R supports both missing data and special values in data structures. 

&nbsp;
#### Missing Data

Missing data is represented as `NA` (Not Available)
and can be used for all the vector types covered in this lesson:


~~~
y1 <- c(0.5, NA, 0.7)
y2 <- c(TRUE, FALSE, NA)
y3 <- c("a", NA, "c", "d", "e")
y4 <- c(1+5i, 2-3i, NA)
~~~
{: .language-r}

&nbsp;

The function `is.na()` indicates the elements of the vectors that represent
missing data, and the function `anyNA()` returns `TRUE` if the vector contains
any missing values:


~~~
x <- c("a", NA, "c", "d", NA)
y <- c("a", "b", "c", "d", "e")
is.na(x)
~~~
{: .language-r}



~~~
[1] FALSE  TRUE FALSE FALSE  TRUE
~~~
{: .output}



~~~
is.na(y)
~~~
{: .language-r}



~~~
[1] FALSE FALSE FALSE FALSE FALSE
~~~
{: .output}



~~~
anyNA(x)
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
anyNA(y)
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}

&nbsp;
#### Other Special Values

`Inf` is infinity. You can have either positive or negative infinity.


~~~
1/0
~~~
{: .language-r}



~~~
[1] Inf
~~~
{: .output}



~~~
-1/0
~~~
{: .language-r}



~~~
[1] -Inf
~~~
{: .output}



~~~
10 * Inf
~~~
{: .language-r}



~~~
[1] Inf
~~~
{: .output}



~~~
1/Inf
~~~
{: .language-r}



~~~
[1] 0
~~~
{: .output}

&nbsp;

`NaN` means Not a Number. It's an undefined value. However, it can still be a placeholder in a numeric vector.

~~~
0/0
~~~
{: .language-r}



~~~
[1] NaN
~~~
{: .output}



~~~
2 * NaN
~~~
{: .language-r}



~~~
[1] NaN
~~~
{: .output}



~~~
Inf * NaN
~~~
{: .language-r}



~~~
[1] NaN
~~~
{: .output}



~~~
x = c(1, 2, NaN)
typeof(x)
~~~
{: .language-r}



~~~
[1] "double"
~~~
{: .output}

***
### Objects Attributes

Objects can have __attributes__. Attributes are metadata that are part of the object and describe different aspects of the object. These include:

* names
* dimnames
* dim
* class
* attributes (contain other forms of metadata)

You can also glean other attribute-like information such as length (works on vectors and lists) or number of characters (for character strings).


~~~
length(1:10)
~~~
{: .language-r}



~~~
[1] 10
~~~
{: .output}



~~~
nchar("Software Carpentry")
~~~
{: .language-r}



~~~
[1] 18
~~~
{: .output}

&nbsp;

We will talk more about attributes when we get to more complex data structures.

***
### Matrices

In R matrices are an extension of the numeric or character vectors. They are not
a separate type of object but simply an atomic vector with dimensions; the
number of rows and columns. As with atomic vectors, the elements of a matrix must
be of the same data type.


~~~
m <- matrix(nrow = 2, ncol = 2)
m
~~~
{: .language-r}



~~~
     [,1] [,2]
[1,]   NA   NA
[2,]   NA   NA
~~~
{: .output}



~~~
dim(m)
~~~
{: .language-r}



~~~
[1] 2 2
~~~
{: .output}

&nbsp;

You can check that matrices are vectors with a class attribute of `matrix` by using
`class()` and `typeof()`.


~~~
m <- matrix(c(1:3))
m
~~~
{: .language-r}



~~~
     [,1]
[1,]    1
[2,]    2
[3,]    3
~~~
{: .output}



~~~
class(m)
~~~
{: .language-r}



~~~
[1] "matrix" "array" 
~~~
{: .output}



~~~
typeof(m)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

&nbsp;

While `class()` shows that m is a matrix, `typeof()` shows that fundamentally the
matrix is an integer vector.

Note that one difference between vectors and matrices is that an otherwise identical vector will return the data type of each element when you use `class()`, while the matrix is a new type of object with `class()` "matrix".


~~~
v = 1:3
v
~~~
{: .language-r}



~~~
[1] 1 2 3
~~~
{: .output}



~~~
class(v)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}



~~~
m = as.matrix(v)
m
~~~
{: .language-r}



~~~
     [,1]
[1,]    1
[2,]    2
[3,]    3
~~~
{: .output}



~~~
class(m)
~~~
{: .language-r}



~~~
[1] "matrix" "array" 
~~~
{: .output}


> ## Data types of matrix elements
> 
> Consider the following matrix:
> 
> 
> ~~~
> FOURS <- matrix(
>   c(4, 4, 4, 4),
>   nrow = 2,
>   ncol = 2)
> ~~~
> {: .language-r}
>
> Given that `typeof(FOURS[1])` returns `"double"`, what would you expect
> `typeof(FOURS)` to return? How do you know this is the case even without
> running this code?
>
> *Hint* Can matrices be composed of elements of different data types?
>
> > ## Solution
> > We know that `typeof(FOURS)` will also return `"double"` since matrices 
> > are made of elements of the same data type. Note that you could do 
> > something like `as.character(FOURS)` if you needed the elements of `FOURS` 
> > *as characters*.
> {: .solution}
{: .challenge}

&nbsp;

Matrices in R are filled column-wise:


~~~
m1 <- matrix(1:6, nrow = 2, ncol = 3)
m1
~~~
{: .language-r}



~~~
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
~~~
{: .output}

... unless you tell it to fill by row explicitly:


~~~
m2 <- matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)
m2
~~~
{: .language-r}



~~~
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
~~~
{: .output}

&nbsp;

Other ways to construct a matrix


~~~
m      <- 1:10
m # so far m is just a vector!
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
dim(m) <- c(2, 5)
m # defining the dimensions converts m to a matrix
~~~
{: .language-r}



~~~
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10
~~~
{: .output}

&nbsp;

This takes a vector and transforms it into a matrix with 2 rows and 5 columns.

Another way is to bind columns or rows using `rbind()` and `cbind()` ("row bind"
and "column bind", respectively).


~~~
x <- 1:3
y <- 10:12
cbind(x, y)
~~~
{: .language-r}



~~~
     x  y
[1,] 1 10
[2,] 2 11
[3,] 3 12
~~~
{: .output}



~~~
rbind(x, y)
~~~
{: .language-r}



~~~
  [,1] [,2] [,3]
x    1    2    3
y   10   11   12
~~~
{: .output}

&nbsp;
#### Indexing matrices

Like vectors, use `[m,n]` to index the *m*th row and *n*th column of a matrix. The row is always specified before the `,` and the column after.


~~~
m <- matrix(1:10, nrow = 2, ncol = 5)
m
~~~
{: .language-r}



~~~
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10
~~~
{: .output}



~~~
m[2, 3]
~~~
{: .language-r}



~~~
[1] 6
~~~
{: .output}

&nbsp;

What if we ask for an index outside the range of a matrix?


~~~
m[3,15]
~~~
{: .language-r}



~~~
Error in m[3, 15]: subscript out of bounds
~~~
{: .error}

***

{% include links.md %}
