---
title: "R Data Types and Data Structures -- Additional Detail"
classdate: "8/28/2020 -- On Your Own"
teaching: 90
exercises: 30
questions:
- "Class questions."
objectives:
- "Class objectives."
keypoints:
- "Class keypoints."
source: Rmd
---

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("02-oyo-R-data-types-structures-")
```

***
## On Your Own

&nbsp;
### A more in-depth look at Data Types in R

To make the best of the R language, you'll need a strong understanding of the
basic data types and data structures and how to operate on them.

Data structures are very important to understand because these are the objects you 
will manipulate on a day-to-day basis in R. Dealing with object conversions is one
of the most common sources of frustration for beginners.

**Everything** in R is an object.

R has 6 basic data types. In addition to the five listed below, there is also
*raw* which is rarely used and will not be discussed in this course.

* character
* numeric (real or decimal; aka "double")
* integer
* logical
* complex

Elements of these data types may be combined to form data structures, such as
atomic vectors. When we call a vector *atomic*, we mean that the vector only 
holds data of a single data type. Below are examples of atomic character vecotrs,
numeric vectors, integer vectors, etc.

* **character**: `"a"`, `"swc"`
* **numeric**: `2`, `15.5`
* **integer**: `2L` (the `L` tells R to store this as an integer)
* **logical**: `TRUE`, `FALSE`
* **complex**: `1+4i` (complex numbers with real and imaginary parts)

R provides many functions to examine features of vectors and other objects, for
example

* `class()` - what kind of object is it (high-level)?
* `typeof()` - what is the object's data type (low-level)?
* `length()` - how long is it (one-dimensional objects)? 
* `dim()` - what are its dimensions? (two-dimensional objects)?
* `attributes()` - does it have any metadata?

Here are a couple of examples:
```{r}
# Example 1 -- a character variable object
x <- "dataset"
typeof(x)
class(x)
attributes(x) # simple objects to not have attributes by default

# Example 2 -- an integer vector object
y <- 1:10
y
typeof(y)
length(y)

# Example 3 -- a numeric vector object
z <- as.numeric(y)
z
typeof(z)
```

&nbsp;

R has many __data structures__. These include

* atomic vector
* list
* matrix
* data frame
* factors

***
### Factors

Factors are a special type of data in R, primarily used to represent categorical data. Factors can be ordered or unordered and are an important class for statistical analysis and for plotting.

Factors look (and often behave) like character vectors, but assuming that they are character vectors can lead to unexpected behavior. Factors are actually integers under the hood, and you need to be careful when treating them
like strings. 

Factors have three essential properties:
* A list of integers.
* A set of labels defining the label for the integer.
* An order for the labels.

The integer defines the value of each element in the factor, the label indicates what that value means, and the order defines the relationship between the values.

Once created, factors can only contain a pre-defined set values, known as
*levels*. By default, R sorts *levels* in alphabetical order. For
instance, let's use the `factor()` command to create a factor with 2 levels:


```{r intro-to-factors}
sex <- factor(c("male", "female", "female", "male"))
sex
```

&nbsp;

Now compare this to a similar `character` vector:
```{r intro-to-factors2}
sex.char <- c("male", "female", "female", "male")
sex.char
```

&nbsp;

Note that the elements of `sex.char` have quotation marks, while the object `sex` had a list of levels.

R will assign `1` to the level `"female"` and `2` to the level `"male"` (because
`f` comes before `m`, even though the first element in this vector is
`"male"`). You can check this by using the function `levels()`, and check the
number of levels using `nlevels()`:

```{r examining-factors}
levels(sex)
nlevels(sex)
```

&nbsp;

One major functional difference is that the elements of the `character` vector only have the inherent order defined by their values (e.g. alphabetical). Sometimes, the order of the factors does not matter, other times you might want
to specify the order because it is meaningful. For instance, "low", "medium", "high" as elements of a character vector have the implicit alphabetical order:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"high" < "low" < "medium"

while the more meaningful conceptual ordering is:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"low" < "medium" < "high"

Factor levels allow us to specify the conceptual order:
```{r, error=TRUE}
food <- factor(c("low", "high", "medium", "high", "low", "medium", "high"))
levels(food)
class(food)
```


&nbsp;

Adding the "levels" input to factor defines the level order if it is non-alphabetic

```{r}
food <- factor(food, levels = c("low", "medium", "high"))
levels(food)
class(food)
min(food) # note that relative operations do not work; why not?
```

&nbsp;

If you want R to interpret relative relationships between elements, you have to be explicit that the order of the factors is important.

```{r}
food <- factor(food, levels = c("low", "medium", "high"), ordered = TRUE)
levels(food)
class(food)
min(food) # now it works!
```

&nbsp;

Note that numeric operations still do not work:

```{r}
food[1] + food[2]
```

&nbsp;

In R's memory, these factors are represented by numbers (1, 2, 3). They are
better than using simple integer labels because factors are self describing:
`"low"`, `"medium"`, and `"high"`" is more descriptive than `1`, `2`, `3`. Which
is low?  You wouldn't be able to tell with just integer data. Factors have this
information built in. It is particularly helpful when there are many levels
(like the subjects in our example data set).

What happens if we try to add an element to our factor that is not in the current list of levels?
```{r}
length(food)
food[8] <- "frog" # doesn't work! The level "frog" is not defined

food[8] <- "low" # note that this works to add an 8th element to `food`
food

food[10] <- "high" # skipping a spot induces the creation of NAs to fill in data
food
```


> ## Representing Data in R
>
> You have a vector representing levels of exercise undertaken by 5 subjects
>
> **"l", "n", "n", "i", "l"** ; n=none, l=light, i=intense
>
> What is the best way to represent this in R?
>
> ```{r, eval=FALSE}
> exercise <- c("l", "n", "n", "i", "l") # (a)
> exercise <- factor(c("l", "n", "n", "i", "l"), ordered = TRUE) # (b)
> exercise < -factor(c("l", "n", "n", "i", "l"), levels = c("n", "l", "i"), ordered = FALSE) # (c)
> exercise <- factor(c("l", "n", "n", "i", "l"), levels = c("n", "l", "i"), ordered = TRUE) # (d)
> ```
>
> > ## Solution
> > Correct solution is **(d)**
> > ```{r}
> > exercise <- factor(c("l", "n", "n", "i", "l"), levels = c("n", "l", "i"), ordered = TRUE)
> > exercise
> > ```
> > &nbsp;
> > 
> > We only expect three categories ("n", "l", "i").
> > We can order these from least intense to most intense, so let's use `ordered`.
> {: .solution}
{: .challenge}

&nbsp;
#### Converting Factors

Converting from a factor to a number can cause problems:

```{r converting-factors}
f <- factor(c(3.4, 1.2, 5))
as.numeric(f)
```

&nbsp;

This does not behave as expected (and there is no warning). The reason is that the apparent numeric values are actually stored as integers (2, 1, 3) with labels ("3.4", "1.2", "5"). R uses the integer vaue when trying to perform the `as.numeric()` function.

The recommended way is to use the integer vector to index the factor levels:

```{r converting-factors-correctly}
levels(f)[f]
```

&nbsp;

The factor really consists of two elements:
* The ordered integer list: `2, 1, 3`
* The "key" indicating which integer corresponds to which level: `1 = 1.2`, `2 = 3.4`, `3 = 5` 

To break this down the `levels(f)[f]`:
1. First we grabe the list of levels using `levels(f)`, which outputs a character vector: "1.2" "3.4" "5".
2. Next we index this list with `[f]`. Because the index requests a numeric representation of the factor `f`, R replaces the `[f]` with `[c(2,1,3)]` (the integer portion of the factor object).
3. R returns the elements of the character list in (1) with the order indicated by the integer list in (2).

To convert that value of `f` to a basic `numeric` type, we still need to assign the values output above using `<-` and the `as.numeric()`:

```{r converting-to-numeric}
f <- levels(f)[f]
f <- as.numeric(f)
f
class(f)
```



***

{% include links.md %}
